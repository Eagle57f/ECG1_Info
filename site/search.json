{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Cours d'informatique en ECG","text":"<p>Sur ce site vous trouverez des cours/fiches pour apprendre le Python, ainsi que les TP de 1ère et 2ème année, des exercices que j'ai fait moi même avec une correction, les DS avec correction, et des ressources supplémentaires.</p> <p>Les PDF des TP de 1ère année sont de Mme. Bruni, ceux de 2ème année de M. Benaddi.</p>","path":["Cours d'informatique en ECG"],"tags":[]},{"location":"#depot-github","level":3,"title":"Dépôt GitHub :","text":"Quelques ressources pour approfondir <ul> <li> <p>Vidéos (ou playlists):</p> <ul> <li>Graven (FR): https://www.youtube.com/watch?v=psaDHhZ0cPs&amp;list=PLMS9Cy4Enq5JmIZtKE5OHJCI3jZfpASbR</li> <li>Docstring (FR): https://www.youtube.com/watch?v=LamjAFnybo0&amp;list=PLXDBYzqsqO3Wut-gQktoqJ30eaOel0hgb</li> <li>FormationVidéo (FR): https://www.youtube.com/watch?v=HWxBtxPBCAc&amp;list=PLrSOXFDHBtfHg8fWBd7sKPxEmahwyVBkC</li> <li>NetworkChuck (EN): https://www.youtube.com/watch?v=mRMmlo_Uqcs</li> <li>freeCodeCamp.org (EN): https://www.youtube.com/watch?v=LHBE6Q9XlzI</li> </ul> </li> <li> <p>Sites web:</p> <ul> <li>Python Doctor (FR): https://python.doctor/</li> <li>w3schools (EN): https://www.w3schools.com/</li> </ul> </li> </ul>","path":["Cours d'informatique en ECG"],"tags":[]},{"location":"1ere/","level":1,"title":"Cours d'informatique de 1ère année","text":"","path":["1ère année","Cours d'informatique de 1ère année"],"tags":[]},{"location":"1ere/#sommaire","level":2,"title":"Sommaire","text":"<ul> <li>Cours 1 - Bases du Python</li> <li>Cours 2 - Boucles for et while, tests</li> <li>Cours 3 - Listes</li> <li>Cours 4 - Fonctions</li> <li>Cours 5 - Matrices avec Numpy</li> <li>Cours 6 - Graphiques avec Matplotlib</li> </ul>","path":["1ère année","Cours d'informatique de 1ère année"],"tags":[]},{"location":"1ere/#exercicesressourcescorrections","level":2,"title":"Exercices/Ressources/Corrections","text":"<ul> <li>Exercices</li> <li>Corrections<ul> <li>Corrections et PDF des TP<ul> <li>TP1</li> <li>TP2</li> <li>TP3</li> <li>TP4</li> <li>TP5</li> <li>TP6</li> </ul> </li> <li>Corrections des DS<ul> <li>DS Final 2024</li> <li>Correction du DS Final 2025</li> </ul> </li> </ul> </li> <li>Ressources<ul> <li>Toutes les fonctions de 1ère année</li> </ul> </li> </ul> Quelques ressources pour approfondir <ul> <li> <p>Vidéos (ou playlists):</p> <ul> <li>Graven (FR): https://www.youtube.com/watch?v=psaDHhZ0cPs&amp;list=PLMS9Cy4Enq5JmIZtKE5OHJCI3jZfpASbR</li> <li>Docstring (FR): https://www.youtube.com/watch?v=LamjAFnybo0&amp;list=PLXDBYzqsqO3Wut-gQktoqJ30eaOel0hgb</li> <li>FormationVidéo (FR): https://www.youtube.com/watch?v=HWxBtxPBCAc&amp;list=PLrSOXFDHBtfHg8fWBd7sKPxEmahwyVBkC</li> <li>NetworkChuck (EN): https://www.youtube.com/watch?v=mRMmlo_Uqcs</li> <li>freeCodeCamp.org (EN): https://www.youtube.com/watch?v=LHBE6Q9XlzI</li> </ul> </li> <li> <p>Sites web:</p> <ul> <li>Python Doctor (FR): https://python.doctor/</li> <li>w3schools (EN): https://www.w3schools.com/</li> </ul> </li> </ul>","path":["1ère année","Cours d'informatique de 1ère année"],"tags":[]},{"location":"1ere/Correction_DS_2024/","level":1,"title":"DS Final Info — ECG1-2","text":"<p>Télécharger la correction</p>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#i-exercices-sur-les-suites","level":2,"title":"I. Exercices sur les suites","text":"","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#i1-suites-recurrentes","level":3,"title":"I.1 Suites récurrentes","text":"<p>Pour chaque suite définie ci-dessous, écrire une fonction Python prenant en paramètre un entier naturel \\( n \\) et renvoyant la valeur de \\( u_n \\). On privilégiera une écriture récursive.</p> <ol> <li> \\[ \\begin{cases} u_0 = 2 \\\\ u_{n+1} = 3u_n^2 - 1 \\end{cases} \\] </li> <li> \\[ \\begin{cases} u_1 = 0 \\\\ u_{n+1} = e^{-u_n} \\end{cases} \\] </li> <li> \\[ \\begin{cases} u_0 = 1,\\quad u_1 = 1 \\\\ u_{n+2} = u_{n+1} + u_n \\end{cases} \\] </li> <li> \\[ \\begin{cases} u_0 = 1 \\\\ u_{n+1} = \\sum_{k=0}^{n} \\frac{u_k}{k^2 + 1} \\end{cases} \\] </li> </ol> <p>Démontrer que :</p> \\[ u_{n+1} = u_n \\cdot \\frac{n^2 + 2}{n^2 + 1} \\]","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#i2-suites-imbriquees","level":2,"title":"I.2 Suites imbriquées","text":"<p>Soient \\( (a_n) \\) et \\( (b_n) \\) définies par :</p> \\[ a_0 = 0,\\quad b_0 = 1 \\] \\[ a_{n+1} = 2a_n + b_n,\\quad b_{n+1} = 2a_n + 3b_n \\] <ol> <li> <p>Calculer \\( a_1, b_1, a_2, b_2 \\)</p> </li> <li> <p>Écrire une fonction Python <code>suites(n)</code> qui renvoie \\( a_n \\) et \\( b_n \\)</p> </li> <li> <p>Soit \\( s_n = a_n + b_n \\). Déterminer une relation de récurrence entre \\( s_n \\) et \\( s_{n+1} \\)</p> </li> <li> <p>Soit \\( t_n = 2a_n - b_n \\). Déterminer une relation de récurrence entre \\( t_n \\) et \\( t_{n+1} \\)</p> </li> </ol>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#ii-simulation-et-frequences","level":2,"title":"II. Simulation et fréquences","text":"","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#ii1-simulation-1","level":3,"title":"II.1 Simulation 1","text":"<p>On lance 3 fois une pièce donnant PILE avec une probabilité \\( \\frac{1}{3} \\). On note \\( X \\) le nombre de PILE obtenus.</p> <ol> <li>Compléter le programme suivant :</li> </ol> <pre><code>from random import *\nx = random()\nif x &lt; ...:\n    piece = \"PILE\"\nelse:\n    piece = \"FACE\"\nprint(piece)\n</code></pre> <ol> <li> <p>Écrire une fonction <code>simulX()</code> qui renvoie la valeur de \\( X \\)</p> </li> <li> <p>Donner la loi de probabilité de \\( X \\) et calculer son espérance</p> </li> </ol>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#ii2-simulation-2","level":3,"title":"II.2 Simulation 2","text":"<p>On lance une pièce (PILE avec probabilité \\( \\frac{1}{3} \\)) jusqu’à obtenir le premier PILE, ou jusqu’au 4ᵉ lancer.</p> <p>On note \\( X \\) le nombre de lancers effectués (maximum 4).</p> <ol> <li> <p>Écrire une fonction <code>simul2X()</code> qui simule cette variable aléatoire</p> </li> <li> <p>Écrire une fonction <code>simultiplex(n)</code> qui renvoie la moyenne de \\( n \\) simulations de \\( X \\)</p> </li> </ol>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#iii-matrices","level":2,"title":"III. Matrices","text":"<ol> <li> <p>Quelle instruction permet d'importer un module pour manipuler des matrices ?</p> </li> <li> <p>Écrire une instruction qui crée la matrice :</p> </li> </ol> \\[ A = \\begin{pmatrix} 1 &amp; 2 &amp; 3 \\\\ 2 &amp; -7 &amp; 6 \\end{pmatrix} \\] <ol> <li> <p>Quelle instruction permet d’effectuer le produit matriciel \\( A \\cdot B \\) ?</p> </li> <li> <p>Quelle instruction permet d’afficher la matrice identité \\( I_n \\) ?</p> </li> <li> <p>Que renvoie l’instruction <code>print(np.size(A))</code> ?</p> </li> <li> <p>Que renvoie <code>print(A[1,2])</code> ?</p> </li> </ol>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#iv-operations-sur-les-listes","level":2,"title":"IV. Opérations sur les listes","text":"<p>Chaque QCM comporte 20 questions avec 4 réponses possibles (1 à 4). Une seule réponse est correcte.</p> <p>La correction est donnée par une liste <code>corr</code>, et chaque copie par une liste <code>cop</code>.</p> <ol> <li> <p>Quelle est la bonne réponse à la question 18 ?</p> </li> <li> <p>Quelle instruction Python permet de l’afficher ?</p> </li> <li> <p>Quel booléen est associé à une réponse fausse ?</p> </li> <li> <p>Écrire la liste <code>corrTM</code> correspondant à la correction de la copie de Tom Matt</p> </li> <li> <p>Écrire une fonction <code>note(cop, corr)</code> qui renvoie le nombre de bonnes réponses</p> </li> <li> <p>Écrire une fonction <code>reussite(cop, corr)</code> qui affiche \"Réussite\" si la note est ≥ 10, sinon \"Échec\"</p> </li> <li> <p>Écrire une fonction <code>note2bonus(cop, corr)</code> qui ajoute un bonus de 2 points si le candidat a plus de 4 bonnes réponses consécutives (note max : 20)</p> </li> </ol>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#v-courbes-representatives","level":2,"title":"V. Courbes représentatives","text":"<p>Tracer la courbe de la fonction :</p> \\[ f(x) = e^{x^2} \\] <p>sur l’intervalle \\([-1;2]\\), avec 200 points régulièrement espacés.</p> <p>Bonus : ajouter une légende.</p>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2024/#correction-ds-2024","level":1,"title":"Correction DS 2024","text":"<pre><code># Des erreurs peuvent êtes présentes dans ce fichier, si vous en trouvez, merci de me le signaler.\n# J'ai surtout répondu aux questions python, pas à celles de maths.\n\n# Sujet : DS Final 2024\n\n# I Exercices sur les suites\n\n# 1.1 Suites récurrentes\n\n# 1.\n\nn=int(input(\"Donnez n: \"))\ndef u1(n):\n    if n==0:\n        return 2\n    return 3*(u1(n-1))**2 - 1\nprint(u1(n))\n\n\n# 2.\n\nimport math\n\nn=int(input(\"Donnez n: \"))\ndef u2(n):\n    if n==1:\n        return 0\n    return math.exp(-u2(n-1))\nprint(u2(n))\n\n\n# 3.\n\nn=int(input(\"Donnez n: \"))\ndef u3(n):\n    if n==0 or n==1:\n        return 1\n    return u3(n-1) + u3(n-2)\nprint(u3(n))\n\n\n# 4. Version avec la somme\n\nn=int(input(\"Donnez n: \"))\ndef u4(n):\n    if n==0:\n        return 1\n    s=0\n    for i in range(n):\n        s=s+(u4(i)/(i**2+1))\n    return s\nprint(u4(n))\n\n\n# 4. Version sans la somme\n\nn=int(input(\"Donnez n: \"))\ndef u4bis(n):\n    if n==0:\n        return 1\n    return u4bis(n-1)*((n-1)**2+2)/((n-1)**2+1)\nprint(u4bis(n))\n\n\n# 1.2 Suites imbriquées\n\n# 2.\n\nn=int(input(\"Donnez n: \"))\ndef suites(n):\n    def a(n):\n        if n==0:\n            return 0\n        return 2*a(n-1) + b(n-1)\n\n    def b(n):\n        if n==0:\n            return 1\n        return 2*a(n-1) + 3*b(n-1)\n\n\n    return a(n), b(n)\n\nprint(suites(n))\n\n\n# 1.3 Suites définies par une somme ou un produit\n\n# 1.\n\nn=int(input(\"Donnez n: \"))\ns=0\nfor i in range(1,n+1):\n    s=s+1/i**2\nprint(s)\n\n\n# 2.b\n\nn=int(input(\"Donnez n: \"))\np=1\nfor i in range(2,n+1):\n    p=p*(1-1/i**2)\nprint(p)\n\n\n# 2.f\n\na=eval(input(\"Donnez a: \"))\ndef seuil(a):\n    n=2\n    v=3/4\n    while v-1/2&gt;a:\n        v=(n+1)/2**n\n        n=n+1\n    return n\nprint(seuil(a))\n\n\n# 3.c\n\nn=int(input(\"Donnez n: \"))\n\ndef a(n):\n    s=0\n    for i in range(1,n+1):\n        s=s+i\n    return s**4\n\ndef b(n):\n    s=0\n    for i in range(1,n+1):\n        s=s+i**4\n    return s\n\ndef difference(n):\n    return a(n) - b(n)\n\nprint(difference(n))\n\n\n\n# II Simulation et fréquences\n\n# II.1 Simulation 1\n\n# 1.\n\nfrom random import *\nx=random()\nif x&lt;1/3:\n    piece=\"PILE\"\nelse:\n    piece=\"FACE\"\nprint(piece)\n\n\n# 2.\n\ndef simulX():\n    i=0\n    for k in range(3):\n        x=random()\n        if x&lt;1/3:\n            i+=1\n    return i\nprint(simulX())\n\n\n# II.2 Simulation 2\n\n# 1.\n\ndef simul2X():\n    for i in range(1, 5):\n        if random() &lt; 1/3:\n            return i\n    return 4\nprint(simul2X())\n\n\n# 2. Version simple\n\nn=int(input(\"Donnez n: \"))\ndef simultipleX(n):\n    s=0\n    for i in range(n):\n        s=s+simul2X()\n    return s/n\nprint(simultipleX(n))\n\n\n# 2. Version avancée\n\nn=int(input(\"Donnez n: \"))\ndef simultipleXbis(n):\n    return sum([simul2X() for _ in range(n)])/n\nprint(simultipleXbis(n))\n\n\n\n# III Matrices\n\n# 1.\n\nimport numpy as np\n\n\n# 2.\n\nimport numpy as np\nA=np.array([[1,2,3], [2,-7,6]])\n\n\n# 3.\n\nimport numpy as np\nB=np.array([[1,2], [3,4], [5,6]]) # Ligne non demandée, pour éviter les erreurs dans ce fichier, ne pas la mettre dans le DS\nnp.dot(A,B)\n\n\n# 4.\n\nimport numpy as np\nnp.eye(n)\n\n\n# 5.\n\nprint(np.size(A)) # Renvoie 6\n\n\n# 6.\n\nprint(A[1,2]) # Renvoie 6, car on commence à compter les lignes et colonnes à partir de 0, et non de 1.\n\n\n\n# IV Opérations sur les listes\n\n# 1.\n\n# Réponse : 1\n\n\n# 2.\ncorr0 = [4, 2, 1, 4, 3, 1, 3, 3, 2, 1, 1, 3, 3, 2, 4, 4, 2, 1, 3, 3]\nprint(corr0[17]) # Renvoie 1, car le premier item de la liste à l'indice 0\n\n\n# 3.\n\n# Réponse : False\n\n\n# 4.\n\ncopTM = [4, 1, 2, 4, 3, 3, 1, 4, 3, 3, 2, 1, 3, 2, 4, 1, 3, 3, 2, 3]\n\ncorrTM = [True, False, False, True, True, False, False, False, False, False, False, False, True, True, True, False, False, False, False, True]\n\n# Approfondissement : Algorithme pour générer cette liste automatiquement :\ncorrTM = [copTM[i]==corr0[i] for i in range(len(copTM))]\nprint(corrTM)\n\n\n# 5.\n\ndef note(cop,corr):\n    n=0\n    for i in range(len(cop)):\n        if corr[i]==cop[i]:\n            n+=1\n    return n\n\nprint(note(copTM, corr0))\n\n\n# 6. Version simple\n\ndef reussite(cop,corr):\n    if note(cop,corr) &gt;= 10:\n        return \"Réussite\"\n    else:\n        return \"Echec\"\nprint(reussite(copTM, corr0))\n\n\n# 6. Version en une ligne\n\ndef reussite(cop,corr):\n    return \"Réussite\" if note(cop,corr)&gt;=10 else \"Echec\"\nprint(reussite(copTM, corr0))\n\n\n# 7.\n\ndef notebonus(cop,corr):\n    n=0\n    for i in range(len(cop)):\n        if corr[i]==cop[i]:\n            n+=1 # Pareil que d'écrire n=n+1\n            if n==4:\n                if note(cop,corr) + 2 &lt;= 20:\n                    return note(cop,corr) + 2\n                else:\n                    return 20\n        else:\n            n=0\n    return note(cop,corr)\n\nprint(notebonus(copTM, corr0))\n\n\n\n# V Courbes représentatives de fonctions\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-1, 2, 200)\ny = np.exp(x**2)\n\nplt.plot(x, y, label='f(x) = e^{x²}')\nplt.title('Courbe représentative de f(x) = e^{x²}')\nplt.legend()\nplt.show()\n</code></pre>","path":["1ère année","DS","DS Final Info — ECG1-2"],"tags":[]},{"location":"1ere/Correction_DS_2025/","level":1,"title":"Correction DS 2025","text":"<p>Télécharger la correction</p> <pre><code># Des erreurs peuvent êtes présentes dans ce fichier, si vous en trouvez, merci de me le signaler.\n# J'ai surtout répondu aux questions python, pas à celles de maths.\n\n# Sujet : DS Final 2025\n\n# Exercice 1\n\n# 1)\n\nimport numpy as np\n\ndef Liste(n):\n    L=[]\n    for i in np.linspace(1,20,n):\n        L.append(int(i))\n    return L\nprint(Liste(30))\n\n# 2)\n\ndef Som(L):\n    s=0\n    for i in L:\n        if i%2==0:\n            s+=i\n    return s\nprint(Som([1,2,3,4,5,6,7,2,3,9,34,63]))\n\n# 3)\nL=[114, 15, 20, 152, 45, 87, 26, 153, 0, -7, 147, 158, 1258]\nprint(Som(L))\n\n# Exercice 2\n\ndef FACTO(n):\n    if n==0 or n==1:\n        return 1\n    return FACTO(n-1)*n\n\n# Exercice 3\n\n# 1)\n\nfrom math import sqrt\n\ndef suite(n):\n    if n==0:\n        return 0.5\n    elif n==1:\n        return 1\n    return sqrt(suite(n-1))+sqrt(suite(n-2))\nprint(suite(5))\n\n\n# Exercice 4\n\ndef pal(L):\n    Lbis=L.copy()\n    Lbis.reverse()\n    return L==Lbis\n\nprint(pal([1,2,3,2,1]))\nprint(pal([1,2,3,4]))\n\n# OU\n\ndef pal(L):\n    return L==L[::-1]\n\nprint(pal([1,2,3,2,1]))\nprint(pal([1,2,3,4]))\n\n\n# Exercice 5\n\n# 1)\n\ndef SIMPLE(L):\n    Lbis=[]\n    for i in L:\n        if i not in Lbis:\n            Lbis.append(i)\n    return Lbis\nprint(SIMPLE([1,3,4,2,1,4,6,2,9,0,1]))\n\n\n# 2)\n\ndef PREMS(L, elem):\n    if elem in L:\n        return L.index(elem)\n    else:\n        return -1\nprint(PREMS([1,2,4,5,2], 2))\nprint(PREMS([1,2,4,5,2], 6))\n\n\n# Exercice 6\n\nLISTE=[1,4,5,2,6,3,6,6,5] # Exemple\n\ndef f(LISTE):\n    m=max(LISTE)\n    for _ in range(LISTE.count(m)):\n        LISTE.remove(m)\n    return max(LISTE)\nprint(f(LISTE))\n\n\n# Exercice 7\n\n# Partie A\n\n# 1)\n\nimport matplotlib.pyplot as plt\n\n\n# 2)\n\nplt.show()\n\n\n# Partie B\n\nmois = [\"Jan\", \"Fev\", \"Mar\", \"Avr\", \"Mai\", \"Juin\"]\ntemperatures = [5, 7, 12, 15, 20, 24]\nprecipitation = [120, 90, 80, 65, 50, 30]\n\nimport matplotlib.pyplot as plt\n\nplt.plot(mois, temperatures)\nplt.title(\"Evolution des températures\")\nplt.xlabel(\"Mois\")\nplt.ylabel(\"Températures\")\nplt.grid()\nplt.show()\n\n\n# Partie C\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x): return (x-2)/(x+3)\n\nx=np.linspace(-2, 5, 100)\ny=f(x)\nplt.plot(x,y)\nplt.show()\n\n\n# Exercice 8\n\n# 1)\n\n# Renvoie [34, -91, 5, 67]\n\n\n# 2)\n\n# Renvoie [-91, 5, 67, -89, 23, 56.12, 3, 73, 82, -19, 50, 6, -11]\n\n\n# 3)\n\n# Renvoie [45, 12, 78.5, 34, -91, 5, 67, -89, -5, 23, 56.12, 3, 73, 82, -19, 50, 6, -11]\n\n\n# 4)\n\n# Renvoie une erreur, car -1 n'est pas dans la liste. Si on ignore l'erreur (Hors Programme),\n# on obtient la même liste que la question précédente.\n\n\n# 5)\n\n# Renvoie [-91, 23, -19]\n\n\n# Exercice 9\n\nimport matplotlib.pyplot as plt\nabscisses = [1, 2.5, 2, 2, 0, 0, -0.5, 1]\nordonnees =[3, 2, 2, 0, 0, 2, 2, 3]\nplt.plot(abscisses, ordonnees)\nplt.grid()\nplt.show()\n\n\n# Exercice 10\n\nfrom math import *\ndef suite(n):\n    if n%2==0:\n        u=log(3)/4\n        for k in range(2, n+1, 2):\n            u = 4*u - 00000000 # Je n'ai pas la formule obtenue à la question précédente\n    else:\n        u=log(2/sqrt(3))\n        for k in range(3, n+1, 2):\n            u = 4*u - 00000000 # Je n'ai pas la formule obtenue à la question précédente\n    return u\nprint(suite(10))\n</code></pre>","path":["1ère année","DS","Correction DS 2025"],"tags":[]},{"location":"1ere/Exercice_Methode_de_Monte_Carlo/","level":1,"title":"Correction : Exercice Méthode de Monte-Carlo","text":"<p>Télécharger la correction</p> <pre><code># Exercice : Méthode de Monte-Carlo pour calculer l'aire sous la courbe de exp(x) entre a et b\n\n\n# Explication de la méthode de Monte-Carlo :\n# 1. On choisit un intervalle [a, b] et on génère n_points points aléatoires dans un rectangle\n#    de largeur b-a et de hauteur max(exp(t)) pour t allant de a à b.\n# 2. On compte combien de ces points sont sous la courbe de exp(x).\n# 3. L'aire sous la courbe est approximée par le ratio du nombre de points sous la courbe sur\n#    le nombre total de points, multiplié par l'aire du rectangle.\n\n# Consigne :\n# La fonction monte_carlo_exp prend en entrée les bornes a et b de l'intervalle ainsi que le\n# nombre de points n_points à générer. Elle renvoie l'aire sous la courbe entre a et b, et\n# affiche un graphique avec la courbe de exp entre a et b, ainsi qu'un nuage de points, avec\n# les points sous la courbe en vert et ceux au-dessus en rouge.\n# Complétez la fonction monte_carlo_exp.\n\n\n\n# Correction possible:\n\n\nimport random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points):\n    y_max = max([math.exp(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(n_points):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= math.exp(x):\n            count_under_curve += 1\n            xs_in.append(x)\n            ys_in.append(y)\n        else:\n            xs_out.append(x)\n            ys_out.append(y)\n\n    area_rectangle = (b - a) * y_max\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [math.exp(x) for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='exp(x)')\n    plt.scatter(xs_in, ys_in, color='green', s=1, label='Sous la courbe')\n    plt.scatter(xs_out, ys_out, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt.title(f\"Monte Carlo pour aire sous exp(x) entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.show()\n\n    return area_under_curve\n\n\na = 0\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points)\nprint(f\"Aire approximative sous exp(x) entre {a} et {b} : {aire}\")\n\n# Correction question BONUS\n\n\nimport random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points, f):\n    y_max = max([f(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(n_points):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= f(x):\n            count_under_curve += 1\n            xs_in.append(x)\n            ys_in.append(y)\n        else:\n            xs_out.append(x)\n            ys_out.append(y)\n\n    area_rectangle = (b - a) * y_max\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [f(x) for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='f(x)')\n    plt.scatter(xs_in, ys_in, color='green', s=1, label='Sous la courbe')\n    plt.scatter(xs_out, ys_out, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt.title(f\"Monte Carlo entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.show()\n\n    return area_under_curve\n\n\na = 1\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points, math.log) # Autre fonction, comme exemple\nprint(f\"Aire approximative entre {a} et {b} : {aire}\")\n</code></pre>","path":["Correction : Exercice Méthode de Monte-Carlo"],"tags":[]},{"location":"1ere/Exercice_Probabilites_1/","level":1,"title":"Correction : Exercice Probabilités 1","text":"<p>Télécharger la correction</p> <pre><code># Exercice 1: Simulation d'une variable aléatoire, sans remise\n\n\n#   On tire aléatoirement trois cartes d'un jeu de n cartes (sans remise), n&gt;4, les cartes sont\n#   numérotées de 0 à n-1.\n#   X est la variable aléatoire qui représente la somme des valeurs des cartes tirées.\n#\n# 1) Simulez par une fonction X(n) X pour 20 cartes, et renvoyez la valeur de X.\n#\n# 2) a. Simulez par une fonction Xk(n, k) k tirages, et renvoyez la moyenne de X sur ces k tirages.\n#    b. Renvoyez également par la fonction Xk(n, k) le pourcentage de fois où X est supérieur à 2*n.\n#\n# 3) a. Affichez un graphique de la moyenne de X en fonction de n, pour n variant de 5 à 200,\n#       et k=1000.\n#    b. Affichez sur ce même graphique le pourcentage de fois où X est supérieur à 2*n en fonction\n#       de n, pour n variant de 5 à 200, et k=1000.\n#    c. Affichez la droite d'équation y=1.5x en pointillés rouges sur le graphique précédent,\n#       la droite doit être derrière les autres courbes sur le graphique (il faut donc mettre\n#       la ligne de code pour créer la droite avant celles pour créer les courbes).\n#    d. Ajoutez un titre, des labels aux axes, une grille et une légende.\n\n\n# Correction possible de l'exercice 1:\n\n# 1)\n\nimport random\n\ndef X(n):\n    L=[i for i in range(0, n+1)]\n    s=0\n    for i in range(3):\n        x=random.randint(0, len(L)-1)\n        a=L.pop(x)\n        s+=a\n    return s  \nprint(X(7))\n\n\n# 2)\n\ndef Xk(n, k):\n    total = 0\n    sup=0\n    for i in range(k):\n        x=X(n)\n        total += x\n        if x &gt; 2*n:\n            sup+=1\n    return total/k, sup/k*100\n\nprint(Xk(20, 1000))\n\n# 3)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn_values = np.linspace(5, 200, 196) # 196 car il y a 196 valeurs entre 5 et 200 (les deux extrêmes inclus)\nplt.plot(n_values, 1.5*n_values, '--', color='red', label=\"y = 1.5x\") # Ligne rouge en pointillés pour x=y\ny_values = [Xk(int(n), 1000)[0] for n in n_values] # On utilise [0] pour obtenir le premier élément des deux retournés par Xk (Donc la moyenne de X)\nplt.plot(n_values, y_values, label=\"Moyenne de X pour n cartes\")\ny2_values = [Xk(int(n), 1000)[1] for n in n_values] # On utilise [1] pour obtenir le second élément des deux retournés par Xk (Donc le pourcentage de fois où X est supérieur à 2*n)\nplt.plot(n_values, y2_values, label=\"Pourcentage de X &gt; 2*n\")\nplt.xlabel(\"Nombre de cartes\")\nplt.ylabel(\"Moyenne de X et\\npourcentage de X &gt; 2*n\")\nplt.title(\"Moyenne de X en fonction de n et pourcentage de fois où X &gt; 2*n,\\npour k=1000\")\nplt.grid()\nplt.legend()\nplt.show()\n\n# Pour tirer aléatoirement k éléments distincts d'une liste de n éléments (k&lt;=n), on peut\n# utiliser la fonction sample(liste, k) de la bibliothèque random, elle n'est pas\n# obligatoire mais peut être utile.\n</code></pre>","path":["Correction : Exercice Probabilités 1"],"tags":[]},{"location":"1ere/Exercice_Probabilites_2/","level":1,"title":"Correction : Exercice Probabilités 2","text":"<p>Télécharger la correction</p> <pre><code># Exercice 2: Chaîne de Markov\n\n\n#   On considère un système avec 3 états numérotés 0, 1, et 2. Le système évolue de manière\n#   probabiliste selon les transitions suivantes:\n#   - Au temps t=0, le système est dans l'état 0 avec une probabilité de 1.\n#   - Si l'état actuel est 0, il peut passer à 0 avec une probabilité de 0.3, à 1 avec une\n#     probabilité de 0.4, et à 2 avec une probabilité de 0.3.\n#   - Si l'état actuel est 1, il peut passer à 0 avec une probabilité de 0.2, à 1 avec une\n#     probabilité de 0.5, et à 2 avec une probabilité de 0.3.\n#   - Si l'état actuel est 2, il peut passer à 0 avec une probabilité de 0.6, à 1 avec une\n#     probabilité de 0.3, et à 2 avec une probabilité de 0.1.\n#   La variable aléatoire X représente l'état du système à chaque instant t.\n#\n# 1) Créez une fonction transition_etat(etat) qui prend l'état actuel en entrée et renvoie le\n#    nouvel état après une transition aléatoire en fonction des probabilités données, affichez\n#    le nouvel état avec comme état actuel l'état 1.\n#\n# 2) Créez une fonction simulation_markov(k) qui simule k transitions successives et renvoie la\n#    suite d'états traversés grâce à une liste, affichez cette liste pour k=20.\n#\n# 3) Créez une fonction pourcentages_etats(etats) qui prend en entrée la liste des états et\n#    renvoie le pourcentage de fois où le système est dans l'état 0, 1 ou 2 après k transitions.\n#    Affichez ces pourcentages pour k=20.\n\n\n\n# Correction possible de l'exercice 2:\n\n# 1)\n\nimport random\n\ndef transition_etat(etat):\n    if etat == 0:\n        prob_0 = 0.3\n        prob_1 = 0.4\n        prob_2 = 0.3 # Les valeurs prob_2 ne sont jamais utilisées pour le random, car on passe à l'état 2 si on ne passe ni à l'état 0 ni à l'état 1 (prob_2=1-prob_0-prob_1). On peut supprimer ces lignes.\n    elif etat == 1:\n        prob_0 = 0.2\n        prob_1 = 0.5\n        prob_2 = 0.3 # Pareil ici\n    else:\n        prob_0 = 0.6\n        prob_1 = 0.3\n        prob_2 = 0.1 # Pareil ici\n\n    tirage = random.random()\n    if tirage &lt; prob_0:\n        return 0\n    elif tirage &lt; prob_0 + prob_1:\n        return 1\n    else:\n        return 2\n\nprint(transition_etat(1)) \n\n\n# 2)\n\ndef simulation_markov(k):\n    etat_courant = 0 # Cas initial\n    etats = [etat_courant]\n    for i in range(k):\n        etat_courant = transition_etat(etat_courant) # On remplace l'état courant par le nouvel état après la transition\n        etats.append(etat_courant)\n    return etats\n\nprint(simulation_markov(20))\n\n\n# 3)\n\ndef pourcentages_etats(etats):\n    comptage_0 = etats.count(0)\n    comptage_1 = etats.count(1)\n    comptage_2 = etats.count(2)\n\n    pourcentage_0 = (comptage_0 / len(etats)) * 100\n    pourcentage_1 = (comptage_1 / len(etats)) * 100\n    pourcentage_2 = (comptage_2 / len(etats)) * 100\n\n    return pourcentage_0, pourcentage_1, pourcentage_2\n\nprint(pourcentages_etats(simulation_markov(20)))\n</code></pre>","path":["Correction : Exercice Probabilités 2"],"tags":[]},{"location":"1ere/Exercices/","level":1,"title":"Exercices","text":"","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#exercices-probabilites","level":2,"title":"Exercices Probabilités","text":"","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#exercice-1-simulation-dune-variable-aleatoire-sans-remise","level":3,"title":"Exercice 1: Simulation d'une variable aléatoire, sans remise","text":"","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#correction","level":4,"title":"Correction","text":"<p>On tire aléatoirement trois cartes d'un jeu de n cartes (sans remise), n&gt;4, les cartes sont numérotées de 0 à n-1. X est la variable aléatoire qui représente la somme des valeurs des cartes tirées.</p> <p>1) Simulez par une fonction X(n) X pour 20 cartes, et renvoyez la valeur de X.</p> <p>2) a. Simulez par une fonction Xk(n, k) k tirages, et renvoyez la moyenne de X sur ces k tirages.</p> <p>b. Renvoyez également par la fonction Xk(n, k) le pourcentage de fois où X est supérieur à 2*n.</p> <p>3) a. Affichez un graphique de la moyenne de X en fonction de n, pour n variant de 5 à 200, et k=1000.</p> <p>b. Affichez sur ce même graphique le pourcentage de fois où X est supérieur à 2*n en fonction de n, pour n variant de 5 à 200, et k=1000.</p> <p>c. Affichez la droite d'équation y=1.5x en pointillés rouges sur le graphique précédent, la droite doit être derrière les autres courbes sur le graphique (il faut donc mettre la ligne de code pour créer la droite avant celles pour créer les courbes).</p> <p>d. Ajoutez un titre, des labels aux axes, une grille et une légende.</p>","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#exercice-2-chaine-de-markov","level":3,"title":"Exercice 2: Chaîne de Markov","text":"","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#correction_1","level":4,"title":"Correction","text":"<p>On considère un système avec 3 états numérotés 0, 1, et 2. Le système évolue de manière probabiliste selon les transitions suivantes:   - Au temps t=0, le système est dans l'état 0 avec une probabilité de 1.   - Si l'état actuel est 0, il peut passer à 0 avec une probabilité de 0.3, à 1 avec une probabilité de 0.4, et à 2 avec une probabilité de 0.3.   - Si l'état actuel est 1, il peut passer à 0 avec une probabilité de 0.2, à 1 avec une probabilité de 0.5, et à 2 avec une probabilité de 0.3.   - Si l'état actuel est 2, il peut passer à 0 avec une probabilité de 0.6, à 1 avec une probabilité de 0.3, et à 2 avec une probabilité de 0.1.</p> <p>La variable aléatoire X représente l'état du système à chaque instant t.</p> <p>1) Créez une fonction transition_etat(etat) qui prend l'état actuel en entrée et renvoie le nouvel état après une transition aléatoire en fonction des probabilités données, affichez le nouvel état avec comme état actuel l'état 1.</p> <p>2) Créez une fonction simulation_markov(k) qui simule k transitions successives et renvoie la suite d'états traversés grâce à une liste, affichez cette liste pour k=20.</p> <p>3) Créez une fonction pourcentages_etats(etats) qui prend en entrée la liste des états et renvoie le pourcentage de fois où le système est dans l'état 0, 1 ou 2 après k transitions. Affichez ces pourcentages pour k=20.</p>","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#methode-de-monte-carlo","level":2,"title":"Méthode de Monte-Carlo","text":"","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices/#correction_2","level":4,"title":"Correction","text":"<p>Méthode de Monte-Carlo pour calculer l'aire sous la courbe de <code>exp(x)</code> entre a et b.</p> <p>Explication de la méthode de Monte-Carlo pour la fonction <code>exp</code>: 1. On choisit un intervalle [a, b] et on génère n_points points aléatoires dans un rectangle de largeur b-a et de hauteur <code>max(exp(t))</code> pour t allant de a à b. 2. On compte combien de ces points sont sous la courbe de <code>exp(x)</code>. 3. L'aire sous la courbe est approximée par le ratio du nombre de points sous la courbe sur le nombre total de points, multiplié par l'aire du rectangle.</p> <p>Consigne :</p> <p>La fonction <code>monte_carlo_exp</code> prend en entrée les bornes a et b de l'intervalle ainsi que le nombre de points n_points à générer. Elle renvoie l'aire sous la courbe de la fonction exp entre a et b, et affiche un graphique avec la courbe de exp entre a et b, ainsi qu'un nuage de points, avec les points sous la courbe en vert et ceux au-dessus en rouge.</p> <p>Complétez la fonction <code>monte_carlo_exp</code>.</p> <p>BONUS: Transformez la fonction <code>monte_carlo_exp</code> pour qu'elle fonctionne pour n'importe quelle fonction mathématique.</p> <p>Télécharger le code à trous</p> <pre><code>import random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points):\n    y_max = max([_____(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(_____):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= math.exp(x):\n            count_under_curve = count_under_curve + _____\n            xs_in._____(x)\n            ys_in._____(y)\n        else:\n            xs_out._____(x)\n            ys_out._____(y)\n\n    area_rectangle = _____\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [_____ for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='exp(x)')\n    plt._____(_____, _____, color='green', s=1, label='Sous la courbe')\n    plt._____(_____, _____, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt._____(f\"Monte Carlo pour aire sous exp(x) entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt._____(\"x\")\n    plt._____(\"y\")\n    plt._____()\n\n    return _____\n\n\na = 0\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points)\nprint(f\"Aire approximative sous exp(x) entre {a} et {b} : {aire}\")\n</code></pre>","path":["1ère année","Exercices"],"tags":[]},{"location":"1ere/Exercices_TP1/","level":1,"title":"TP1 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Ex 1\n'''print(f\"\"\"\n125*347={125*347}\n4x3,52+(2,5-7,5)^3={4*3.52+(2.5-7.5)**3}\n(3,25+7,8)/(1,26-0,57)={(3.25+7.8)/(1.26-0.57)}\n6x((10,68-2,2786)**4)/(5**2)={6*((10.68-2.2786)**4)/(5**2)}\n\"\"\")\n\nprint(f\"\"\"\na=125, b=11 : {divmod(125,11)} OU a=125, b=11 : {(125//11,125%11)}\na=689, b=17 : {divmod(689,17)} OU a=689, b=17 : {(689//17,689%17)}\na=-145, b=21 : {divmod(-145,21)} OU a=-145, b=21 : {(-145//21,-145%21)}\na=-368, b=-6 : {divmod(-368,-6)} OU a=-368, b=-6 : {(-368//-6,-368%-6)}\n\"\"\")'''\n\n# Ex 2\n# a) Erreur, b) 1, c) 1, d) 0\n\n#Ex 3\n\"\"\"\n# a)\na=5\nb=2\na,b=b,a\nprint(a,b)\n\n# b) x=x+5 revient à incrémenter x de 5\"\"\"\n\n# Ex 4\n\"\"\"# a)\na,b,c,d,e=0,2,4,6,8 # a=0, b=2, c=4, d=6 e=8\na,b,c,d,e=a,d,c,b,a # a=a=0, b=d=6, c=c=4, d=b=2, e=a=0\nprint(a,b,c,d,e)\n\n# b)\na,b,c=2,3,-5\nb=2\nc=3*a\nprint(a,b,c)\"\"\"\n\n# Ex 5\n\"\"\"# Pour les nombres négatifs, int enlève la partie décimale (donc au supérieur près pour les négatifs)\n# alors que floor arrondit à l'inférieur près (pour les positifs et négatifs).\n\nfrom fractions import *\na=Fraction(3,5)\nprint(a) # Print la fraction simplifiée au maximum\np=a.numerator\nprint(p) # Print le numérateur\nq=a.denominator\nprint(q) # Print le dénominateur \n\nfrom fractions import Fraction\nprint((1+Fraction(3,4))/(Fraction(5,2)+Fraction(7,3)))\n# OU\nprint(Fraction((1+Fraction(3,4)),(Fraction(5,2)+Fraction(7,3))))\n\nprint((Fraction(19,15)-Fraction(3,7))/(Fraction(11,2)+Fraction(8,35)))\n# OU\nprint(Fraction((Fraction(19,15)-Fraction(3,7)),(Fraction(11,2)+Fraction(8,35))))\"\"\"\n\n# Ex 6\n\"\"\"from math import *\na=sqrt(2) # Racine carré de 2\nb=sqrt(3) # Racine carré de 3\nc=5\nprint(a**2==2) # False car il y a une erreur d'arrondi\nprint((sqrt(3))**2==3) # False car il y a une erreur d'arrondi\nprint(a**2+b==c) # True car les erreurs d'arrondi se compensent\nprint(a&gt; 1.732) # False car inférieur\"\"\"\n</code></pre>","path":["1ère année","TP","TP1 — Exercices et correction"],"tags":[]},{"location":"1ere/Exercices_TP2/","level":1,"title":"TP2 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Ex 1\n# input sert à demander une valeur à l'utilisateur pendant l'exécution du programme.\n\n# Ex 2\n# Le script 1 ne fonctionne pas car type(input(\"\"))==Str\n# Le script 2 fonctionne car eval permet de transformer ici un chiffre en Str en Float\n\n# Ex 3\n\"\"\"l=[eval(input(\"Note 1 et coeff: \")), eval(input(\"Note 2 et coeff: \")), eval(input(\"Note 3 et coeff: \"))]\nprint(sum([i[0]*i[1] for i in l])/sum([i[1] for i in l]))\"\"\"\n\n# Ex 4\n\"\"\"from math import pi\nr=float(input(\"Rayon de la sphère: \"))\nprint(f\"Aire: {4*pi*(r**2)}, Volume: {(4/3)*pi*(r**3)}\")\"\"\"\n\n# Ex 5\n\"\"\"p=[float(input(\"Prix: \")), float(input(\"Pourcentage: \"))]\nprint(p[0]*(1-p[1]/10020))\"\"\"\n\n# Ex 6\n\"\"\"AB=[eval(input(\"Coos de A\")),\n    eval(input(\"Coos de B\"))]\n\nVdir=((AB[1][0])-(AB[0][0]), (AB[1][1])-(AB[0][1]))\n\nc=-((AB[1][0])*(-Vdir[1])+(AB[1][1])*Vdir[0])\nprint(f\"{-Vdir[1]}*x+{Vdir[0]}*y+{c}=0\")\"\"\"\n\n\n\n# Ex 7\n# Le script 1 fonctionne, mais pas le 2 car il manque une tabulation avant print, la boucle est donc vide\n\n# Ex 8\n# d=16, d=12, d=9, d=5\n# En enlevant la tabulation, on sort une instruction de la boucle, qui ne sera donc exécuté qu'une seule fois après  fin de boucle\n\n# Ex 9\n# range(borne de départ inclue, borne d'arrivée exclue, pas)\n# renvoie un objet range que l'on peut parcourir et qui, transformé en liste, donne une liste de chiffres allant de Binf à Bsup exclue avec un pas donné (1 par defaut)\n\"\"\"print(list(range(1,20,2)))\"\"\"\n\n# Ex 10\n# Le script 1 print qu'une seule fois à la fin du programme, alors que le script 2 print à chaque itération de la boucle\n\n# Ex 11\n\"\"\"for i in range(21):\n    print(i**2)\"\"\"\n\n# Ex 12\n# a) Car il faut sommer pour tout k allant de 1 à n. Or la borne sup est exlue en python, donc il faut aller jusqu'à n+1\n# b) L'erreur est le manque de tabulation avant S=S+1/k**2\n\n# Ex 13 \n\"\"\"def f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=1/i**3\n    return s\nprint(f(100000))\"\"\"\n\n'''def f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=1/i**4\n    return s\nprint(f(100000))'''\n\n\"\"\"def f(n):\n    s=0\n    for i in range(n+1):\n        s+=(1/2)**i\n    return s\nprint(f(1000))\"\"\"\n\n\"\"\"def f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=(1/i*(i+1))\n    return s\nprint(f(1000))\"\"\"\n\n# Ex 14\n\"\"\"def f(n:int):\n    \\\"\"\"n&gt;=1\\\"\"\"\n    p=1\n    for i in range(1,n+1):\n        p*=(1+1/i)\n    return p\nprint(f(10))\"\"\"\n\n\"\"\"def f(n:int):\n    p=1\n    for i in range(1,n+1):\n        p*=(i/(1+i))\n    return p\nprint(f(10))\"\"\"\n\n\"\"\"def f(n:int):\n    p=1\n    for i in range(2,n+1):\n        p*=(1-(1/(i**2)))\n    return p\nprint(f(10))\"\"\"\n\n\"\"\"def f(n:int):\n    p=1\n    for i in range(1,n+1):\n        p*=i\n    return p\nprint(f(10))\"\"\"\n\n# Ex 15\n\"\"\"def f1(n):\n    s=0\n    for i in range(n+1):\n        s+=2*i+1\n    return s\nprint(f1(11))\n\ndef bonus1(n):\n    s=0\n    i=0\n    while 2*i+1&lt;=2*n+1:\n        s+=2*i+1\n        i+=1\n    return s\nprint(bonus1(11))\n\ndef f1(n):\n    s=0\n    for i in range(2*n+2):\n        if not i%2:\n            s+=i+1\n    return s\nprint(f1(11))\n\ndef f1(n):\n    s=0\n    for i in range(0, 2*n+2, 2):\n        s+=i+1\n    return s\nprint(f1(11))\"\"\"\n\n\"\"\"def f1(n):\n    s=0\n    for i in range(n+1):\n        s+=2*i\n    return s\nprint(f1(11))\n\ndef bonus1(n):\n    s=0\n    i=0\n    while 2*i&lt;=2*n:\n        s+=2*i\n        i+=1\n    return s\nprint(bonus1(11))\n\ndef f1(n):\n    s=0\n    for i in range(2*n+1):\n        if i%2:\n            s+=i+1\n    return s\nprint(f1(11))\n\ndef f1(n):\n    s=0\n    for i in range(0, 2*n+2, 2):\n        s+=i\n    return s\nprint(f1(11))\"\"\"\n\n# Ex 16\n'''def f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=(1/i**2)\n    return s\nprint(f(1000))\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=(1/(2*i)**2)\n    return s\nprint(f(1000))\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=(1/(2*i-1)**2)\n    return s\nprint(f(1000))'''\n\n# Ex 17\n\"\"\"from math import sqrt\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        s+=(1/sqrt(i))\n    return s\nprint(f(10))\"\"\"\n\n#Ex 18\n\"\"\"u=1\nx=eval(input(\"Valeur de x: \"))\nwhile u&gt;x:\n    u=(u**2)/(u**2+1)\n    print(u)\"\"\"\n# Renvoye la premiere valeur de la suite u(n) a partir de laquelle u&lt;=x\n\n# Ex 19\n\"\"\"from math import log\nx=eval(input(\"Valeur de x: \"))\nn=1\nwhile log(n)&lt;x:\n    n+=1\nprint(n)\"\"\"\n\n# Ex 20\n\n\"\"\"from math import exp\ndef f(n):\n    for i in range(n,n+11):\n        print((exp(i)-i)/(exp(i)+2*i))\nf(0)\n\ndef f(n):\n    i=n\n    while i&lt;n+11:\n        print((exp(i)-i)/(exp(i)+2*i))\n        i+=1\nf(100) #Limit = 1\"\"\"\n\n\n# Ex 21\n\n\"\"\"from math import log\ndef f(a):\n    u=0\n    for i in range(1,a+1):\n        u+=(1/i)\n    v=u\n    u-=log(a)\n    v-=log(a+1)\n    print((u+v)/2)\n\nf(100)\"\"\"\n\n\n# Ex 23\n\"\"\"def f(a):\n    k=1\n    s=0\n    while k&lt;a:\n        s+=(1/k**3)\n        k+=1\n    print(s)\n\nf(1000)\n\ndef f(a):\n    k=1\n    s=0\n    while k&lt;a:\n        s+=(1/k**4)\n        k+=1\n    print(s)\nf(1000)\n\ndef f(a):\n    k=1\n    s=0\n    while k&lt;a:\n        s+=(0.5**k)\n        k+=1\n    print(s)\nf(1000)\n\ndef f(a):\n    k=1\n    s=0\n    while k&lt;a:\n        s+=(1/(k*(k+1)))\n        k+=1\n    print(s)\nf(1000)\"\"\"\n\n# Ex 24\n\n\"\"\"def f(a):\n    s=0\n    i=1\n    while s&lt;a:\n        s+=i\n        i+=1\n    print(s)\nf(11)\"\"\"\n\n# Ex 25 \n\"\"\"from math import factorial\ndef f(a):\n    if a==0:\n        print(1)\n    elif a&lt;0:\n        print(\"Existe pas\")\n    else:\n        p=1\n        for i in range(2,a+1):\n            p*=i\n        print(p)\nf(-1)\n\ndef f(a):\n    print(factorial(a) if a&gt;=0 else \"Existe pas\")\nf(-1)\"\"\"\n\n# Ex 26\n\"\"\"def f(a:float|int):\n    print(a if a&gt;=0 else -a)\n\nf(-5)\nf(5)\nf(0)\n\"\"\"\n# Ex 27\n\"\"\"def f(a,b):\n    print(max(a,b))\nf(2,-5)\n\ndef f(a,b):\n    print(a if a&gt;=b else b)\nf(2,-5)\"\"\"\n\n# Ex 28\n\"\"\"import fractions\ndef f(a,b):\n    print(fractions.Fraction(-b,a) if a!=0 else \"x inexistant\")\nf(3,26)\nf(0,5)\"\"\"\n\n# Ex 30\n\n\"\"\"def f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=i+j\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=i+j\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\n\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=i*j\n    print(s)\n\nf(100)\n\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=i*j\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=(3*i-2*j)**2\n    print(s)\n\nf(100)\n\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=(3*i-2*j)**2\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\"\"\"\n\n\n# Ex 31\n\n\"\"\"def f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=min(i,j)\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=min(i,j)\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=i if i&lt;=j else j\n\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=max(i,j)\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=max(i,j)\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=i if i&gt;=j else j\n\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=abs(i-j)\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    i=1\n    while i&lt;=n:\n        j=1\n        while j&lt;=n:\n            s+=abs(i-j)\n            j+=1\n        i+=1\n    print(s)\n\nf(100)\n\ndef f(n):\n    s=0\n    for i in range(1,n+1):\n        for j in range(1, n+1):\n            s+=i-j if i-j&gt;=0 else j-i\n\n    print(s)\n\nf(100)\"\"\"\n\n# Ex 32\n\"\"\"def d(a,b,p):\n    def f(x): return x**3+3*x-5\n    while abs(b-a)&gt;p:\n        m=(a+b)/2\n        if (f(a)*f(m)&lt;0):\n            b=m\n        else:\n            a=m\n        print(m)\n\nd(10,1,0.0001)\n\nfrom math import exp\n\ndef d(a,b,p):\n    def f(x): return x+exp(x)-8\n    while abs(b-a)&gt;p:\n        m=(a+b)/2\n        if (f(a)*f(m)&lt;0):\n            b=m\n        else:\n            a=m\n        print(m)\n\nd(100,-100,0.0001)\n\ndef d(a,b,p):\n    def f(x): return (exp(x)-exp(-x))/2-4\n    while abs(b-a)&gt;p:\n        m=(a+b)/2\n        if (f(a)*f(m)&lt;0):\n            b=m\n        else:\n            a=m\n        print(m)\n\nd(100,-100,0.0001)\"\"\"\n\n# Ex 33\n\"\"\"def f(x):\n    print(bin(x))\nf(100)\n\ndef f(x):\n    b=[]\n    while x!=0 and x!=1:\n        b.append(x%2)\n        x//=2\n    b.append(x)\n    print(\"\".join(str(i) for i in b[::-1]))\nf(100)\"\"\"\n\n# Ex 35\nfrom math import sqrt, log\n\ndef f(x): print(x+7 if x&gt;=1 else x**2)\nf(100)\n\ndef f(x): print(abs(x-1) if x&lt;3 else sqrt(x**2+1) if x&gt;=3 and x&lt;8 else log(x-6))\nf(100)\n\ndef f(x): print(x if x==1 else (x+5)/(x+2) if x&gt;=-1 and x&lt;6 else x**2+2*x-3)\nf(100)\n</code></pre>","path":["1ère année","TP","TP2 — Exercices et correction"],"tags":[]},{"location":"1ere/Exercices_TP3/","level":1,"title":"TP3 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Ex 1\n\"\"\"L = [ -1, 2 , 8 , 7 , -3 , -3 , 7 , 9 , 2 , -1 , -1 , 6, 0 , 7 , 10]\nprint(L.count(0)) # Renvoie le nombre d’occurrences de la valeur.\nprint(L.index(2)) # Renvoie le premier indice de la valeur.\nprint(L.pop(7)) # Supprime de la liste et renvoye l'élément à l'index choisi (dernier par défaut).\nprint(L)\nL.insert(3,\"4\") # insert(i,o) : Insére un objet o avant l'index i.\nprint(L)\nL.reverse()\nprint(L) # Inverse la liste\nL.remove(8) # Supprime la première occurence de la valeur dans la liste\nprint(L)\nL = [ -1, 2 , 8 , 7 , -3 , -3 , 7 , 9 , 2 , -1 , -1 , 6, 0 , 7 , 10]\nL.sort() # Trie la liste par ordre croissant et renvoye None. Le tri est sur place (c'est-à-dire que la liste elle-même est modifiée) et stable (c'est-à-dire que l'ordre de deux éléments égaux est conservé).  Si une fonction clé est donnée, applique-la une fois à chaque élément de la liste et les trie, par ordre croissant ou décroissant, en fonction de leurs valeurs de fonction. L'indicateur inverse peut être configuré pour trier par ordre décroissant.\nprint(L)\"\"\"\n\n# Ex 2\n\"\"\"L =[\"Bonjour\",\"comment\",\"vas\",\"tu\",\"aujourd'hui\",\"?\"]\nprint(L[1:5:2]) # Slicing : object Slice(debut inclu (0 par defaut), fin exclue (len(l) par défaut), pas (1 par défaut))\"\"\"\n\n# Ex 3\n\"\"\"L=[ -1 , 5 , 8 , -9 , 12 , 7 , 3 , 5 , 12 ]\nprint(sum(L)) # Renvoie la somme de tout les termes de la liste\nprint(min(L)) # Renvoie la valeur minimale parmis tout les termes de la liste\nprint(max(L)) # Renvoie la valeur maximale parmis tout les termes de la liste\"\"\"\n\n# Ex 4\n\"\"\"printemps=[ \"mars\", \"avril\", \"mai\"]\nete=[\"juin\",\"juillet\", \"aout\"]\nautomne=[\"septembre\", \"octobre\", \"novembre\"]\nhiver=[\"decembre\", \"janvier\", \"fevrier\"]\n\nsaison=[printemps, ete, automne, hiver]\n\nprint(saison[3]) # Renvoie la liste hiver\nprint(saison[2][1]) # Renvoie octobre\nprint(saison[0 :3]) # Renvoie les listes printemps, été et automne\nprint(saison[ 1 ][0 : 2 ]) # Renvoie juin et juillet\"\"\"\n\n# Ex 5\n\"\"\"L=[2,3,1,7,9,5]\nfor k in range(len(L)):\n    if k not in L:\n        print(\"Le nombre\",k,\" n'est pas dans la liste L\")\n# Ce programme renvoie le premier entier inf ou égal a la longueur de la liste L qui n'est pas dans L. Ne renvoie rien si tout les entiers inf ou egal a la longueur de L sont dans L.\"\"\"\n\n# Ex 6\n\"\"\"abscisse=[0,1,2,3,4,5,6,7]\nordonnee=[3*x+5 for x in abscisse]\nprint(ordonnee) # Renvoie une liste contenant les valeurs de f(k) avec k parcourant les valeurs de la suite abscisse.\n\nX=[i for i in range(21)]\nY=[x**2-2*x+1 for x in X]\"\"\"\n\n# Ex 7\n\"\"\"L1=[2]\nL2=[i for i in range(21)]\nL3=[i for i in range(0,101,3)]\nL4=[i**2 for i in range(1,31)]\nL5=[i+1 for i in range(5,128,2)]\nimport numpy.random as rd\nL6=[rd.randint(1,11) for i in range(10)]\nprint(len(L1), len(L2), len(L3), len(L4), len(L5), len(L6))\"\"\"\n\n# Ex 8\nL=[1,2,5,7,7,8,7,9,4,5,2,4,6,8,7,3,1]\nfor i in L:\n    while L.count(i)&gt;1:\n        L.remove(i)\nprint(L)\n\nprint([i for i in L if i&gt;6])\n\nprint([i for i in L if i%2==0])\n\nmax=L[0]\nfor i in L:\n    if i&gt;max:\n        max=i\nprint(max)\n\nmin=L[0]\nfor i in L:\n    if i&lt;max:\n        min=i\nprint(min)\n\nn=0\nfor _ in L:\n    n+=1\nprint(n)\n</code></pre>","path":["1ère année","TP","TP3 — Exercices et correction"],"tags":[]},{"location":"1ere/Exercices_TP4/","level":1,"title":"TP4 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Ex 1\n\"\"\"from math import log, sqrt\ndef f(l, a, mode):\n    def fa(x): return x**2+2*x-1\n    def fb(x): return log(x**2+1)\n    def fc(x): return log(x+sqrt(1+x**2))\n    i=l[0]\n    output=[]\n    while i&lt;=l[1]:\n        output.append(fa(i) if mode==\"a\" else fb(i) if mode==\"b\" else fc(i))\n        i+=a\n    return output\nprint(f([-2,3], 0.5, \"a\")) # Marche aussi sans renvoyer de liste, grande à la fonction join (voir Ex 3)\nprint(f([-3,3], 0.25, \"b\"))\nprint(f([-4,4], 0.5, \"c\"))\"\"\"\n\n# Ex 2\n\"\"\"def f(x): return x*3\ndef g(x): return x**3\"\"\"\n\n# Ex 3\n\"\"\"def f(): return \" \".join([str(i*7) for i in range(1,11)])\nprint(f())\"\"\"\n\n# Ex 4\n\"\"\"def tjk(j,k):\n    def tn(n): return \" \".join([str(n*i) for i in range(1,11)])\n    return \"\\n\".join(([str(tn(i)) for i in range(j,k+1)]))\nprint(tjk(1,10))\"\"\"\n\n# Ex 5\n\"\"\"def test(x,y):\n    somme = 0\n    for i in range(y) :\n        somme = somme + x\n    return somme\nprint(test(10,5)) # Renvoie x*y\"\"\"\n\n# Ex 6\n\"\"\"def max3(a, b, c):\n    return a if a &gt; b and a &gt; c else b if b &gt; a and b &gt; c else c\nprint(max3(1,5,-2))\"\"\"\n\n\"\"\"def max3(a, b, c):\n    l=[a, b, c]\n    l.sort(reverse=True)\n    return l[0]\nprint(max3(1,5,-2))\"\"\"\n\n#Ex 7\n\"\"\"from math import log\ndef a(n):\n    p=1\n    for i in range(2,n+1):\n        p*=log(1-1/(i**2))\n    return p\nprint(a(10))\n\ndef ba(n):\n    s=1\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            s+=min(i,j)\n    return s\nprint(ba(10))\n\ndef bb(n):\n    s=1\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            s+=max(i,j)\n    return s\nprint(bb(10))\n\ndef bc(n):\n    s=1\n    for i in range(1,n+1):\n        for j in range(1,n+1):\n            s+=abs(i-j)\n    return s\nprint(bc(10))\"\"\"\n\n# Ex 8\n\"\"\"def f(l, n):\n    return n in l\nprint(f([1,2,56,4,6,2,5,6,5,6,8,99,5,5,2,22,7], 7))\"\"\"\n\n# Ex 9\n\"\"\"def nfibo(n):\n    l=[1,1]\n    for i in range(n):\n        l.append(l[i]+l[i+1])\n    return l[n]\nprint(nfibo(10))\n\ndef fibo(n):\n    l=[1,1]\n    for i in range(n):\n        l.append(l[i]+l[i+1])\n    return l\nprint(fibo(10))\"\"\"\n\n# Ex 10\n# a)\n\"\"\"from math import factorial\nprint(factorial(8)/(factorial(8-5)*factorial(5)))\n\ndef coef_bino(n,p):\n    return factorial(n)/(factorial(p)*factorial(n-p))\nprint(coef_bino(8,5))\n\nfrom math import prod\ndef coef_bino(n,p):\n    def facto(k):\n        return prod([i for i in range(1,k+1)])\n    return facto(n)/(facto(p)*facto(n-p))\nprint(coef_bino(8,5))\n\ndef coef_bino(n,p):\n    def facto(k):\n        p=1\n        for i in range(1,k+1):\n            p*=i\n        return p\n    return facto(n)/(facto(p)*facto(n-p))\nprint(coef_bino(8,5))\n\"\"\"\n# b)\n\"\"\"def bino(n, k, i=1, r=1):\n    if i&lt;=k:\n        return bino(n,k,i+1,r*((n-k+i)/i))\n    return r\nprint(bino(8,5))\"\"\"\n\n# c)\n# 1) On cherche la valeur a la n ieme ligne et k ieme rangée du triangle de pascal, on va donc recréer ce triangle\n\"\"\"n=8\nk=5\ntriangle=[[1]]\nfor i in range(1, n+1):\n    rangee=[1] # Chaque rangee commence par 1\n    for j in range(1, i):\n        rangee.append(triangle[i-1][j-1]+triangle[i-1][j])\n    rangee.append(1) # Chaque rangee termine par 1\n    triangle.append(rangee)\nprint(triangle[n][k])\"\"\"\n\n# 2)\n\"\"\"def bino(n, k):\n    if k == 0 or k == n:\n        return 1\n    return bino(n - 1, k - 1) + bino(n - 1, k)\nprint(bino(8,5))\"\"\"\n\n# Ex 11\n\"\"\"from math import sqrt\ndef f(a:int|float,b:int|float,c:int|float,u0:int|float,u1:int|float,n:int=None, *, value:bool=True) -&gt; str:\n    '''\n    Return the value of u_n if value=True, otherwise return the general expression of u_n.\n    The n parameter can be omitted if value=False.\n\n        Parameters:\n            a (int|float): Value of a in ax^2+bx+c=0\n            b (int|float): Value of b in ax^2+bx+c=0\n            c (int|float): Value of c in ax^2+bx+c=0\n            u0 (int|float): Value of u_0\n            u1 (int|float): Value of u_1\n            n (int): Number of iterations\n            value (bool): Set to True to return the value of u_n, False to return the general expression of u_n.\n\n        Returns:\n            un (str): Value of u_n if value=True, otherwise the general expression of u_n.\n    '''\n    delta=b**2-4*a*c\n    if delta&gt;0:\n        x1=(-b+sqrt(delta))/(2*a)\n        x2=(-b-sqrt(delta))/(2*a) \n\n        alpha=(u1-x2*u0)/(x1-x2)\n        beta=u0-alpha\n\n        un=alpha*x1**n+beta*x2**n\n        return f\"u_{n}={un}\" if value==True else f\"u_n={alpha}*{x1}^n*{beta}*{x2}^n\"\n\n    elif delta==0:\n        x0=(-b)/(2*a) \n\n        alpha=(u1-x0*u0)/(x0)\n        beta=u0\n\n        un=(alpha*n+beta)*x0**n\n        return f\"u_{n}={un}\" if value==True else f\"u_n=({alpha}*n+{beta})*{x0}^n\"\n    else: return None\n\n\nprint(f(1,2,1,10,1,-2, value=True))\nprint(f(1,2,1,10,1,-2, value=False))\"\"\"\n\n# Ex 12\n\"\"\"from math import sin, log, sqrt, exp, cos\n\nfrom math import pi, e\ndef fa(a,b,n,mode=\"sin\",methode=\"rect\"):\n    def f(x): return sin(x) if mode==\"sin\" else log(x) if mode==\"log\" else exp(-x**2) if mode ==\"exp\" else sqrt(1-x**2)\n    Sinf=0\n    if methode==\"rect\":\n        for k in range(1,n+1):\n            Sinf+=((b-a)*(f(a+((k-1)*(b-a))/n)+f(a+((k)*(b-a))/n)))/(2*n)\n    else:\n        for k in range(1,n+1):\n            Sinf+=((b-a)/n)*f(a+(((k-1)*(b-a))/n))\n    Ssup=0\n    if methode==\"rect\":\n        for k in range(1,n+1):\n            Ssup+=((b-a)/n)*f(a+(((k)*(b-a))/n))\n\n\n    def derivate_max(mode, interval, n):\n        a, b = interval\n        x = a\n        max_abs_value = 0\n\n        while x &lt;= b:\n            try:\n                abs_value = abs(cos(x) if mode==\"sin\" else 1/x if mode==\"log\" else -2*x*exp(-x**2) if mode==\"exp\" else (-x)/(2*sqrt(1-x**2)))\n                if abs_value &gt; max_abs_value:\n                    max_abs_value = abs_value\n            except ZeroDivisionError:\n                pass\n\n            x += 1/n\n\n\n        return max_abs_value\n\n    if methode==\"rect\": \n        erreur = ((b-a)**2)/(2*n)*abs(derivate_max(mode, (a,b), n))\n        return (Sinf, Ssup), erreur\n    else:\n        return Sinf\n\nprint(fa(0,pi/2,100000,\"sin\",\"rect\"))\nprint(fa(1,e,100000,\"log\",\"rect\"))\nprint(fa(0,1,100000,\"exp\",\"rect\"))\nprint(fa(-1,0,100000,\"sqrt\",\"rect\"))\n\nprint(fa(0,pi/2,100000,\"sin\",\"trap\"))\nprint(fa(1,e,100000,\"log\",\"trap\"))\nprint(fa(0,1,100000,\"exp\",\"trap\"))\nprint(fa(-1,0,100000,\"sqrt\",\"trap\"))\"\"\"\n\n# Ex 13\n\"\"\"def nb_chiffres(n):\n    b = n\n    m = 0\n    while b &gt;= 1:\n        m = m + 1\n        b = n // 10**m\n    return m\n\nn = eval(input(\"Entrer un entier naturel n: \"))\nprint(nb_chiffres(n)) # Ce script renvoie le nombre de chiffre d'un nombre (Ex: 123993 est composé de 6 chiffres).\n                      # Pour ce faire, le programme va compter le mobre de fois qu'on peut diviser ce nombre par 10 avant qu'il devienne inférieur à 1.\n                      # Ce nombre de fois étant le nombre de chiffres composant le nombre (car on déplace la virgule de 1 vers la gauche à chaque fois).\n\ndef nb_chiffres_recursive(n):\n    if n &lt; 10:\n        return 1 # Si n&lt;10 (cas de base, arrête la recursion)\n    else:\n        return 1 + nb_chiffres_recursive(n // 10) # Les +1 s'additionnent seulement a la fin des appels recursifs. Ils restent en attente jusqu'a la fin de la recursion.\n\n                                                  # Lorsque le cas de base est atteint, on commence à \"remonter\" dans la pile d'appels, en ajoutant le +1 de chaque appel précédent. Pour 1234 :\n                                                  # Le quatrième appel (nb_chiffres_recursive(1)) retourne 1.\n                                                  # Ce 1 retourne au troisième appel (nb_chiffres_recursive(12)), qui avait 1 + nb_chiffres_recursive(1). Donc, il devient 1 + 1 = 2.\n                                                  # Ensuite, ce 2 retourne au deuxième appel (nb_chiffres_recursive(123)), qui devient 1 + 2 = 3.\n                                                  # Enfin, ce 3 retourne au premier appel (nb_chiffres_recursive(1234)), qui devient 1 + 3 = 4.\nprint(nb_chiffres_recursive(n))\"\"\"\n\n# Ex 14   =&gt; A revoir\n\"\"\"def a(n):\n    if n==0:\n        return 1 # Valeur de u_0\n    return (a(n-1)+1)/(a(n-1)+2)\nprint(a(10))\n\nfrom math import sqrt\ndef b(n):\n    if n==0:\n        return 1\n    return sqrt(b(n-1)+1)\ndef bbis(n): return b(n+1)\nprint(bbis(10)) # Demander si on a le droit d'utiliser une deuxième fonction.\n\ndef c(n):\n    if n==0:\n        return 1\n    return c(n-1)**2-2\ndef cbis(n): return c(n+1)\nprint(cbis(10)) # De même que pour b)\"\"\"\n\n# Ex 15\n\"\"\"def u(a,n):\n    if n==0:\n        return 1\n    return (1/2)/(u(a,n-1)+(a/u(a,n-1)))\ndef ubis(n): return u(n+1)\nprint(ubis(3,10))\"\"\"\n\n# Ex 16\n\"\"\"import random as rd\ndef f():\n    return rd.choice([\"Roger\", \"Monique\"])\nprint(f())\ndef f():\n    return [\"Roger\", \"Monique\"][rd.randint(0,1)]\nprint(f())\n\ndef g(n):\n    l=[f() for i in range(n)]\n    for i in range(n):\n        print(i)\n    cR = l.count(\"Roger\")\n    cM = l.count(\"Monique\")\n    print(f\"Le plus tombé:\", \"Monique\" if cM&gt; cR else \"Roger\" if cR &gt; cM else \"Les deux sont tombés le même nombre de fois\")\ng(10)\"\"\"\n\n# Ex 17\n\"\"\"# a)\nphrase = \"Aujourd hui en info je fais un peu de python pour être au point le jour du concours et je m amuse beaucoup\"\n# b)\ni=0\nfor k in phrase:\n    i+=1\nprint(i) # On compte les espaces\nprint(len(phrase)) # On compte les espaces\n# c)\nprint(phrase.count(\"e\")+phrase.count(\"E\"))\n# d)\nprint(phrase.count(\"a\")+phrase.count(\"A\"))\n# e)\ndef nombre(phrase, lettres:str, separated):\n    '''letters or str, separated by |\n    if separated=True, upper and lower case letters are distinguished\n    else upper and lower case letters are not distinguished (use lower case letters)'''\n    return sum([phrase.count(l) for l in lettres.split(\"|\")]) if separated==True else sum([phrase.lower().count(l) for l in lettres.split(\"|\")])\n# f)\nprint(nombre(phrase, \"a|A| |m\", False))\"\"\"\n</code></pre>","path":["1ère année","TP","TP4 — Exercices et correction"],"tags":[]},{"location":"1ere/Exercices_TP5/","level":1,"title":"TP5 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Cours 12) Résolution d'un système d'équations :\n\"\"\"import numpy as np\na = np.array([[2,3,3,1], [-4,-6,3,2], [-1,1,1,1], [-2,-1,1,1]])\nb = np.array([15,3,5,1])\nx = np.linalg.solve(a, b)\nprint(x) # Renvoie la valeur des 4 variables\"\"\"\n\n# Exercices :\n# Ex 1\n\"\"\"import numpy as np\nm = input(\"Enter une matrice\")\nprint(np.array(eval(m)))\"\"\"\n\n# Ex 2\n\"\"\"import numpy as np\ndef symetrique(m:np.array):\n    if np.shape(m) == np.shape(m.T):\n        return True if (m==m.T).all() or (m==-m.T).all() else False\n    return False\nprint(symetrique(np.array([[1,2,3],[4,5,6],[7,8,9]])))\nprint(symetrique(np.array([[1,2,3],[2,4,5],[3,5,6]])))\nprint(symetrique(np.array([[0,2,-1],[-2,0,4],[1,-4,0]])))\"\"\"\n\n# Ex 3\n\"\"\"import numpy as np\ndef mat1(n,p):\n    return np.random.random((n,p))\nprint(mat1(3,5))\n\ndef mat6(n,p):\n    return 6*np.random.random((n,p))+1 # On mutiplie par 6 car card([|1,6|])==6 et on ajoute 1 car on commence à 1.\nprint(mat6(3,5))\n\ndef matpair(n,p):\n    return 2*np.random.randint(0,10000,(n,p))\nprint(matpair(3,5))\"\"\"\n\n# Ex 4\n\"\"\"import numpy as np\ndef diag(n):\n    m = np.zeros((n, n), dtype=int)\n    for i in range(n): # On commence par la diagonale centrale, puis on remplie les diagonales de chaque coté, puis encore de chaqque coté...\n        np.fill_diagonal(m[i:], n - i) # Au dessus\n        np.fill_diagonal(m[:, i:], n - i) # En dessous\n    return m\nprint(diag(5))\"\"\"\n\n# Ex 5\n\"\"\"def diag2(n):\n    m = np.zeros((n, n), dtype=int)\n    np.fill_diagonal(m, n)\n    np.fill_diagonal(np.fliplr(m), n)\n    return m\nprint(diag2(5))\"\"\"\n\n# Ex 6\n# A faire après avoir fait le cours sur les matrices\n</code></pre>","path":["1ère année","TP","TP5 — Exercices et correction"],"tags":[]},{"location":"1ere/Exercices_TP6/","level":1,"title":"TP6 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger ma correction</p> <pre><code># Ex 1\n\"\"\"import matplotlib.pyplot as plt\nabscisses = [0.5, 3.5 , 1, 2, 3, 0.5]\nordonnees = [2, 2, 0, 3, 0, 2]\nplt.plot(abscisses, ordonnees)\nplt.show()\"\"\"\n\n\"\"\"import matplotlib.pyplot as plt\nabscisses = [0.5, 1 , 3, 3.5, 2, 0.5]\nordonnees = [2, 0, 0, 2, 3, 2]\nplt.plot(abscisses, ordonnees)\nplt.show()\"\"\"\n\n# Ex 2\n\"\"\"from math import exp\nimport matplotlib.pyplot as plt\nx=[i/10 for i in range(-50,21)]\ny=[exp(i/10) for i in range(-50,21)]\nplt.plot(x,y)\nplt.show()\"\"\"\n\n# Ex 3\n\"\"\"import numpy as np\nimport matplotlib.pyplot as plt\nx=np.linspace(-5,5,101)\ny=[i**2-3*i+1 for i in x]\nplt.plot(x,y)\nplt.show()\"\"\"\n\n# Ex 4\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0, 3 * np.pi, 0.01)[1:]\nprint(x)\nplt.plot(x, np.cos(x),label='$y=sin(x)/x$')\nplt.legend()\nplt.grid()\nplt.show()\n# Je n'ai pas obtenu d'erreur en exécutant le programme, mais pour éviter le problème de la fonction qui n'est pas définie en 0,\n# il suffit de retirer la première valeur de la liste x (qui est 0), en ajoutant [1:] après np.arange(...).\"\"\"\n\n# Ex 5\n\"\"\"import numpy as np\nimport matplotlib.pyplot as plt\n# x = np.linspace(-1,1,100)\n# y = np.where(x == 0, np.nan, 1 / x) # ne marche que si 0 est inclu dans x, ce qui n'est pas le cas ici, on va donc diviser le linespace en deux.\n# plt.plot(x, 1/x,label='$y=sin(x)/x$')\n\nx1 = np.linspace(-1,-0.01,50)\nx2 = np.linspace(0.01,1,50)\nplt.plot(x1, 1/x1,label='$y=sin(x)/x$  (x &lt; 0)')\nplt.plot(x2, 1/x2,label='$y=sin(x)/x$  (x &gt; 0)')\nplt.legend()\nplt.grid()\nplt.show()\"\"\"\n\n# 5 : Autres exemples\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(-2*np.pi, 2* np.pi, 0.01)\nfor i in range(1,4):\n    texte=\"$y=cos(\"+str(i*2)+\"x)$\"\n    plt.plot(x, np.cos(i*2*x),label =texte)\nplt.legend()\nplt.show()\"\"\"\n\n# Ex 6\n# 1)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(-4*np.pi, 4* np.pi, 0.01)\ntexte=\"$y=cos(x)$\"\nplt.plot(x, np.cos(x),label =texte)\ntexte=\"$y=cos(x)$\"\nplt.plot(x, np.sin(x),label =texte)\nplt.legend()\nplt.show()\"\"\"\n\n# 2)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0, 1.5, 0.01)\ntexte=\"$y=x$\"\nplt.plot(x, x,label =texte)\ntexte=\"$y=sqrt(x)$\"\nplt.plot(x, np.sqrt(x),label =texte)\ntexte=\"$y=x**2$\"\nplt.plot(x, x**2,label =texte)\ntexte=\"$y=x**3$\"\nplt.plot(x, x**3,label =texte)\nplt.legend()\nplt.show()\n\"\"\"\n\n# Ou alors :\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0, 1.5, 0.01)\nfor f, t in [(x, \"x\"),(np.sqrt(x), \"np.sqrt(x)\"), (x**2, \"x**2\"), (x**3, \"x**3\")]:\n    texte=f\"$y={t}$\"\n    plt.plot(x, f,label =texte)\nplt.legend()\nplt.show()\"\"\"\n\n# 3)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx1 = np.arange(-7, 3, 0.01)\nx2 = np.arange(3, 7, 0.01)\nplt.plot(x1, 3*(np.sqrt(1-(x1**2)/49)),label='$y=3*(np.sqrt(1-(x**2)/49))$  (x&lt;3)')\nplt.plot(x2, 3*(np.sqrt(1-(x2**2)/49)),label='$y=3*(np.sqrt(1-(x**2)/49))$  (x&gt;3)')\nplt.legend()\nplt.grid()\nplt.show()\"\"\"\n\n# 4)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(-1, 1, 0.01)\nplt.plot(x, 9-8*abs(x),label='$y=9-8*abs(x)$')\nplt.legend()\nplt.grid()\nplt.show()\"\"\"\n\n# 5)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0, 3, 0.01)\nplt.plot(x, 0.5*((np.sqrt(x)+np.sqrt(2))**2+(np.sqrt(x)-np.sqrt(2))**2),label='$y=0.5*((np.sqrt(x)+np.sqrt(2))**2+(np.sqrt(x)-np.sqrt(2))**2)$')\nplt.legend()\nplt.grid()\nplt.show()\n# Le fait que cette focntion est linéaire est prévisible car en développant les carrés et en les additionnant,\n# on obtient 2x+4, puis en multipliant par 0.5, on obtient x+2.\"\"\"\n\n# 6)\n\"\"\"import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0, 10, 0.01)\nplt.plot(x, x*(np.floor(x) + 1),label='$y=sum(x,$ $0$ $to$ $abs(x))$  (0&lt;=x&gt;=10)')\nplt.legend()\nplt.grid()\nplt.show()\"\"\"\n</code></pre>","path":["1ère année","TP","TP6 — Exercices et correction"],"tags":[]},{"location":"1ere/TP1/","level":1,"title":"TP 1 - Introduction à l'algorithmique, présentation de python et exemples","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#quelques-symboles","level":2,"title":"Quelques symboles","text":"Symbole Signification + Addition <code>1+2==3</code> - Soustraction <code>1-2==-1</code> * Multiplication <code>2*3==6</code> ** Puissance <code>2**3==8</code> / Division <code>6/2==3</code> // Quotient division euclidienne <code>7//2==3</code> % Reste division euclidienne <code>7%2==1</code> <p>Les chiffres à virgule s'écrivent avec un point en python. Ex: <code>1.005</code></p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#variables-et-affichage","level":2,"title":"Variables et affichage","text":"<p>Un algorithme python s'exécute dans l'ordre(1ère ligne-&gt;dernière ligne), il faut donc initialiser les variables avant de les utiliser.</p> <pre><code>a=\"t\"\nb=2\nc=3\nprint(a,c,b)\n</code></pre> Renvoie<pre><code>t 3 2\n</code></pre> <p>Python est sensible à la casse, donc <code>Variable != variable</code>.</p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#le-point-virgule","level":2,"title":"Le point-virgule","text":"<p>En python, le point-virgule <code>;</code> n'est pas obligatoire à la fin d'une ligne. Il est possible de l'utiliser pour séparer plusieurs instructions sur une même ligne, mais ce n'est vraiment pas recommandé (PEP-0008: \"Compound statements (multiple statements on the same line) are generally discouraged\").</p> <pre><code>a=1; b=2; print(a+b)\n</code></pre> Renvoie<pre><code>3\n</code></pre> <p>Dans certains cas, l'utilisation du point-virgule peut même donner des erreurs, comme pour les instructions <code>if</code>, <code>for</code>, <code>while</code> et <code>def</code>.</p> <pre><code>print('Hi') ; for i in range (4): print ('Hello')\n</code></pre> Renvoie<pre><code>SyntaxError: invalid syntax\n</code></pre> <p>Il est donc préférable de ne pas l'utiliser.</p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#premieres-fonctions","level":2,"title":"Premières fonctions","text":"abs(x) int(x) max(a,b,c,...) min(a,b,c,...) round(x, n) Valeur absolue <code>abs(-3)==3</code> Supprime la partie fractionnaire <code>int(-3.7)==-3</code> Maximum <code>max(2.5,-3,6)==6</code> Minimum <code>min(2.5,-3,6)==-3</code> Arrondi à 10^(-n) près <code>round(3.577,1)==3.6</code>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#importer-une-bibliotheque","level":2,"title":"Importer une bibliothèque","text":"<p>Une bibliothèque est un ensemble de fonctions et variables prédéfinies. Il faut toujours importer la bibliothèque avant d'utiliser une fonction ou variable de cette bibliothèque. Le plus souvent, il est préférable d'importer les bibliothèques au début du fichier, afin quelles soient disponibles dans tout le fichier.</p> <p>Pour importer une bibliothèque, par exemple la bibliothèque math:</p> <pre><code>import math\nprint(math.pi, math.e)\n</code></pre> Renvoie<pre><code>3.141592653589793 7.38905609893065\n</code></pre> <p>Pour importer une fonction ou variable d'une bibliothèque:</p> <pre><code>from math import pi\nprint(pi)\n</code></pre> Renvoie<pre><code>3.141592653589793\n</code></pre> <p>Attention, en important de cette façon, on n'importe que <code>pi</code>, pas toute la bibliothèque <code>math</code>. Donc on ne peut pas écrire <code>math.pi</code> par exemple:</p> <pre><code>from math import pi\nprint(pi)\nprint(math.pi)\n</code></pre> Renvoie<pre><code>3.141592653589793\n    print(math.pi)\n        ^^^^\nNameError: name 'math' is not defined # (1)!\n</code></pre> <ol> <li>Erreur car on a importé seulement <code>pi</code>, pas toute la bibliothèque <code>math</code>.</li> </ol> <p>Pour importer toutes les fonctions et variables d'une bibliothèque:</p> <pre><code>from math import *\nprint(pi, exp(2))\n</code></pre> Renvoie<pre><code>3.141592653589793 7.38905609893065\n</code></pre> <p>Il est possible de renommer une bibliothèque (on appelle ce nouveau nom un alias), on l'utilisera surtout pour les bibliothèques <code>numpy</code> et <code>matplotlib.pyplot</code>: <pre><code>import math as m\nprint(m.pi)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre></p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#premiere-bibliotheque-math","level":2,"title":"Première bibliothèque: math","text":"<p>Il faut importer la bibliothèque math avant d'utiliser les fonctions ou variables de cette bibliothèque.</p> math.pi math.floor(x) math.sqrt(x) π ⌊x⌋ <code>math.floor(-3.7)==-4</code> √x <code>math.sqrt(9)==3</code> <p><code>math.pi</code> n'est pas une fonction mais une variable, il ne faut donc pas écrire <code>math.pi()</code> mais <code>math.pi</code>.</p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#bibliotheque-fractions","level":2,"title":"Bibliothèque fractions","text":"<p>Permet de manipuler des fractions. Toutes les opérations possibles avec les entiers et les flottants sont aussi possibles avec les fractions. Les fractions sont toujours automatiquement simplifiées.</p> <p>Ne pas écrire <code>from Fraction import *</code>, mais <code>from fractions import *</code>.</p> Pour mieux comprendre <p>Le nom de la librairie est <code>fractions</code> et une classe (un \"outil\") de cette bibliothèque est <code>Fraction</code>. Un import est de la forme <code>from fichier import outil</code> ou fichier est le nom de la bibliothèque et outil est le nom de la classe, fonction ou variable qu'on souhaite utiliser.</p> <pre><code>from fractions import *\nnumerateur=3\ndenominateur=12\na=Fraction(numerateur, denominateur)\nprint(a.numerator)\nprint(a.denominator)\nprint(a)\nb=Fraction(2, 3)\nprint(a*b, a/b, a+b, a-b, a//b, a**b)\n</code></pre> Renvoie<pre><code>1\n4  \n1/4\n1/6 3/8 11/12 -5/12 0 0.3968502629920499\n</code></pre>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP1/#symboles-de-tests","level":2,"title":"Symboles de tests","text":"Symbole Signification == Égal &lt; Strictement inférieur &gt; Strictement supérieur != N'est pas égal &lt;= Inférieur ou égal &gt;= Supérieur ou égal <p>Si le test est vrai (Ex: <code>6==2*3</code>), alors il renvoie <code>True</code>, sinon <code>False</code>.</p>","path":["1ère année","Cours","TP 1 - Introduction à l'algorithmique, présentation de python et exemples"],"tags":[]},{"location":"1ere/TP2/","level":1,"title":"TP 2 - Boucles for et while, tests","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#fonction-input-et-eval","level":2,"title":"Fonction input et eval","text":"<p>La fonction <code>input()</code> permet de demander une valeur à l'utilisateur. Cette valeur peux être n'importe quelle chaîne de caractères. La valeur retournée par input sera toujours une chaîne de caractère <code>str</code>, même si on entre une valeur comme <code>34</code>, <code>1.8</code> ou <code>True</code>.</p> <p><code>input</code> prend 1 argument qui est le texte affiché dans la demande de la valeur (Exemple: <code>input(\"Donnez un entier entre 1 et 10: \")</code>).</p> <p>Pour obtenir un <code>int</code> lorsque l'utilisateur entre un entier, un <code>float</code> lorsque l'utilisateur entre un nombre décimal, ..., il faut utiliser la fonction eval, qui grâce au contexte (donc grâce à la \"forme\" de la valeur : 2 =&gt; int, 1.2 =&gt; float, ...), eval va transformer le <code>str</code> en un autre type.</p> <pre><code>print(input(\"Donne un nombre\")) # L'utilisateur entre 2 =&gt; le programme affiche \"2\"\nprint(eval(input(\"Donne un nombre\"))) # L'utilisateur entre 3 =&gt; le programme affiche 3\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#boucles-for","level":2,"title":"Boucles <code>for</code>","text":"<p>La boucle <code>for</code> permet de répéter une action un nombre connu de fois.</p> <p>Elle est de la forme:</p> <p><pre><code>a=2\nb=7\nc=2\nfor i in range(a, b, c):\n    print(i) # Il faut indenter les lignes à l'intérieur de la boucle\n</code></pre> La boucle ci-dessus prends les valeurs entre a et b-1, avec a et b entiers. Si on ajoute la valeur c, on va avancer de c en c entre a et b, donc a, a+c, a+2c, ... jusqu'à ce que a+kc soit supérieur ou égal à b (dans quel cas la boucle s'arrête).</p> <p>Par exemple, on peut utiliser cette boucle pour calculer uₙ :</p> <pre><code>u=2 # Valeur de u₀\nn=10\nfor i in range(n): # Lorsqu'on met une seule valeur, la boucle va de 0 à n-1, donc la boucle se lance n fois.\n    u=u*3+4\nprint(u) # Affiche u₁₀\n</code></pre> <p>On peut utiliser la valeur i, qui prend les valeurs parcourues par range(a,b,c). Par exemple pour calculer la somme des entiers entre 0 et n:</p> <pre><code>S=0\nn=10\nfor i in range(n+1):\n    S=S+i\nprint(S)\n</code></pre> <p>La boucle <code>for</code> permet également de calculer la somme ou le produit de termes (qui peuvent être en fonction de i):</p> <pre><code>s=0 # Pour les sommes de termes, il faut initialiser la variable à 0\na=2\nb=10\nfor i in range(a, b):\n    s=s+i+2\nprint(s)\n</code></pre> <p><pre><code>p=1 # Pour les produits de termes, il faut initialiser la variable à 1\na=2\nb=10\nfor i in range(a, b):\n    p=p*(i+2)\nprint(p)\n</code></pre> Pour calculer la limite d'une somme ou d'un produit, il suffit de choisir un b très grand.</p>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#boucles-while","level":2,"title":"Boucles <code>while</code>","text":"<p>La boucle <code>while</code> est utilisée lorsqu'on veut répéter une action tant qu'une condition n'est pas atteinte.</p> <p>Par exemple, pour afficher les entiers entre 0 et n-1:</p> <pre><code>a=0\nb=5\nwhile a&lt;b: # Ici, la boucle est répetée jusqu'à ce que a&gt;=b\n    print(a)\n    a=a+1\n</code></pre> <p>Grâce à la boucle while, on peut trouver le premier k tel que uₖ est par exemple supérieur à une valeur.</p> <pre><code>u=0 # La valeur de u₀\nk=0\nwhile u&lt;20:\n    k=k+1\n    u=u**2+2\nprint(k)\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#fonctions-de-la-bibliotheque-math","level":2,"title":"Fonctions de la bibliothèque <code>math</code>","text":"<p>Il faut importer math avant de les utiliser.</p> math.exp(x) math.log(x) math.log2(x) math.log10(x) eˣ <code>math.exp(0)==1</code> ln(x) <code>math.log(1)==0</code> Logarithme base 2 <code>math.log2(8)==3</code> Logarithme base 10 <code>math.log10(10)==2</code>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#tests","level":2,"title":"Tests","text":"<pre><code>a=eval(input(\"Donnez un chiffre appartenant à Z: \"))\nif a==0:\n    print(\"a est égal à 0\")\nelif a&gt;0:\n    print(\"a est supérieur à 0\")\nelse:\n    print(\"a est inférieur à 0\")\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#fonction-de-la-bibliotheque-random","level":2,"title":"Fonction de la bibliothèque random","text":"<pre><code>import random\nprint(random.random()) # Renvoie un float entre O inclu et 1 exclu\nprint(random.random()*10) # Renvoie un float entre 0 inclu et 10 exclu\nprint(random.random()*10+4) # Renvoie un float entre 4 inclu et 14 exclu\nprint(int(random.random()*10+5)) # Renvoie un int entre 4 inclu et 14 inclu\n\nprint(random.randint(4,14)) # Renvoie un int entre 4 inclu et 14 inclu\n</code></pre> <p>Ces fonctions existent également dans la bibliothèque <code>numpy</code>, mais certaines différences sont présentes. Par exemple, <code>numpy.random.randint(a, b)</code> renvoie un int entre a inclus et b exclus, alors que <code>random.randint(a, b)</code> renvoie un int entre a inclus et b inclus.</p> <pre><code>import numpy as np\nimport random as rd\nprint(np.random.random()) # Renvoie un float entre 0 inclu et 1 exclu\n\nprint(rd.randint(4,14)) # Renvoie un int entre 4 inclu et 14 inclu\nprint(np.random.randint(4,15)) # Renvoie un int entre 4 inclu et 15 exclu\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#algorithme-de-conversion-en-binaire-base-2","level":2,"title":"Algorithme de conversion en binaire (base 2)","text":"<pre><code>n = eval(input(\"Donnez un nombre entier naturel: \"))\nnbin = \"\"\nif n == 0:\n    nbin = \"0\"\nelse:\n    while n &gt; 0:\n        nbin = str(n%2) + nbin # Il faut ajouter les valeurs à gauche\n        n //= 2\nprint(nbin)\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#algorithme-de-dichotomie-version-sans-fonctions","level":2,"title":"Algorithme de dichotomie (version sans fonctions)","text":"<p>Qu'il faudra soit apprendre par coeur, soit savoir retrouver rapidement.</p> <pre><code>p=eval(input(\"Précision: \"))\na=eval(input(\"Valeur de a: \"))\nb=eval(input(\"Valeur de b: \"))\nwhile abs(b-a)&gt;p:\n    m=(a+b)/2\n    if (a**3+3*a-5)*(m**3+3*m-5)&lt;0:\n        b=m\n    else:\n        a=m\nprint([a,m,b]) # x est compris entre a et b, et (a+b)/2 est le milieu de cet intervalle, donc la meilleure approximation\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP2/#algorithme-de-dichotomie-version-avec-fonctions","level":2,"title":"Algorithme de dichotomie (version avec fonctions)","text":"<pre><code>def d(a,b,f,p): # a et b deux réels entre lesquels il faut trouver alpha tel que f(alpha)=0, f la fonction et p la précision (par exemple 0.001)\n    while abs(b-a)&gt;p:\n        if f(a)*f((a+b)/2)&lt;0:\n            b=(a+b)/2\n        else:\n            a=(a+b)/2\n    return [a,(a+b)/2,b] # x est compris entre a et b, et (a+b)/2 est le milieu de cet intervalle, donc la meilleure approximation\ndef f(x): return x**3+3*x-5 # Mettre ici la fonction qu'il faut étudier, par exemple x**3+3*x-5\nprint(d(10,1,f,0.0001))\n</code></pre>","path":["1ère année","Cours","TP 2 - Boucles for et while, tests"],"tags":[]},{"location":"1ere/TP3/","level":1,"title":"TP 3 - Listes","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p>","path":["1ère année","Cours","TP 3 - Listes"],"tags":[]},{"location":"1ere/TP3/#introduction-aux-listes","level":2,"title":"Introduction aux listes","text":"<p>Une liste est une structure de données qui contient une collection d'objets Python. Ces objets peuvent être des <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, d'autres listes, des fonctions, ... Une liste est une structure ordonnée, ce qui signifie que l'ordre des éléments est préservé.</p> <p>Une liste s'écrit avec des crochets, et une virgule entre chaque objet de la liste.</p> <pre><code>liste_a = [1, -3, \"Bonjour\", \"\", True, 1.06, [\"Deuxième\", \"liste\"]]\nliste_b = [] # Une liste peut être vide\n</code></pre> <p>Les éléments d'une liste sont numérotés, le premier élément est l'élément d'indice 0, le deuxième d'indice 1, ... De plus, le dernier élément est l'élément d'indice -1, l'avant dernier d'indice -2, ... Ce qui permet de pouvoir accéder au dernier élément de la liste sans connaître la longueur de celle-ci.</p> <pre><code>liste_a = [1, -3, \"Bonjour\", \"\", True, 1.06, [\"Deuxième\", \"liste\"]]\n\nprint(liste_a[0]) # Renvoie 1\nprint(liste_a[2]) # Renvoie \"Bonjour\"\nprint(liste_a[6]) # Renvoie [\"Deuxième\", \"liste\"]\nprint(liste_a[-1]) # Renvoie [\"Deuxième\", \"liste\"]\nprint(liste_a[-2]) # Renvoie 1.06\n</code></pre> <p>Pour concaténer, donc \"coller\" ensemble deux listes, on utilise l'opérateur <code>+</code>. Pour \"coller\" la même liste plusieurs fois une derrière l'autre, on utilise l'opérateur <code>*</code>.</p> <pre><code>liste_a = [1, 2, 3, 4]\nliste_b = [\"5\", \"6\", \"7\"]\nprint(liste_a+liste_b) # Renvoie [1, 2, 3, 4, \"5\", \"6\", \"7\"]\nprint(liste_b+liste_a) # Renvoie [\"5\", \"6\", \"7\", 1, 2, 3, 4]\nprint(liste_a*3) # Renvoie [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n</code></pre> <p>On peut parcourir une liste en utilisant une boucle <code>for</code>:</p> <pre><code>v=\"\"\nfor i in [\"a\", \"b\", \"c\", \"d\"]:\n    v = v+i\nprint(v) # Renvoie \"abcd\"\n</code></pre> <p>De même qu'une liste, on peut parcourir une chaîne de caractères:</p> <pre><code>liste=[]\nfor i in \"Une phrase\":\n    liste = liste+[i]\nprint(liste) # Renvoie ['U', 'n', 'e', ' ', 'p', 'h', 'r', 'a', 's', 'e']\n</code></pre> <p>Pour ajouter un élément à une liste, on utilise la fonction <code>.append()</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\nliste.append(\"bonjour\")\nprint(liste) # Renvoie ['1', 'b', True, 'bonjour']\n</code></pre> <p>Pour changer la valeur d'un élément on utilise l'opérateur <code>=</code>:</p> <pre><code>liste=[\"1\", 4, True]\nliste[1]=23.3\nprint(liste) # Renvoie ['1', 23.3, True]\n</code></pre> <pre><code>p=[0,2,4,6,8,10]\nfor k in range(0,6):\n    p[k]=p[k]+1\nprint(p) # Renvoie [1, 3, 5, 7, 9, 11]\n</code></pre> <p>Pour connaitre le nombre d'éléments d'une liste, on utilise la fonction <code>len()</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\nprint(len(liste)) # Renvoie 3\n</code></pre> <p>Pour supprimer un élément d'une liste dont on connait l'emplacement dans la liste, on utilise le mot clé <code>del</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\ndel liste[1]\nprint(liste) # Renvoie ['1', True]\n</code></pre> <p>On peut créer des listes de listes (utile pour les matrices par exemple):</p> <pre><code>liste=[[1,2,3],[4,5,6],[7,8,9]]\nprint(liste[1][2]) # Renvoie 6\nprint(liste[2][-1]) # Renvoie 9\n\nl1=[1,2,3]\nl2=[4,5,6]\nliste=[l1,l2]\nprint(liste[1]) # Renvoie [4,5,6]\n</code></pre> <p>Pour extraire une partie de liste, on utilise la syntaxe <code>[debut:fin:pas]</code> (on appelle cette manipulation <code>slicing</code>): La valeur finale n'est pas atteinte. <pre><code>liste=[1,2,3,4,5,6,7,8,9]\nprint(liste[1:5]) # Renvoie [2, 3, 4, 5]\nprint(liste[1:5:2]) # Renvoie [2, 4]\nprint(liste[::2]) # Renvoie [1, 3, 5, 7, 9]\nprint(liste[::-1]) # Renvoie [9, 8, 7, 6, 5, 4, 3, 2, 1]\nprint(liste[5:2:-1]) # Renvoie [6, 5, 4]\n</code></pre></p>","path":["1ère année","Cours","TP 3 - Listes"],"tags":[]},{"location":"1ere/TP3/#fonctions-utiles-pour-les-listes","level":2,"title":"Fonctions utiles pour les listes","text":"<ul> <li><code>.count(élément)</code>: Permet de compter le nombre d'occurences d'un élément dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.count(\"a\")) # Renvoie 4\n</code></pre> <ul> <li><code>.index(élément)</code>: Permet de connaitre l'indice de la première occurence d'un élément dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.index(\"b\")) # Renvoie 1\n</code></pre> <ul> <li><code>.pop(index)</code>: Supprime un élément d'une liste à un index (emplacement dans la liste) spécifique et renvoye cet élément. Si aucun index n'est spécifié, elle supprime et retourne le dernier élément de la liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.pop(3)) # Renvoie \"b\"\nprint(liste) # Renvoie ['a', 'b', 'a', 'c', 'b', 'a', 'a']\nvar = liste.pop()\nprint(var) # Renvoie \"a\"\nprint(liste) # Renvoie ['a', 'b', 'a', 'c', 'b', 'a']\n</code></pre> <ul> <li><code>.insert(index, élément)</code> : Permet d'insérer un élément à un index spécifique.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.insert(2, \"d\")\nprint(liste) # Renvoie ['a', 'b', 'd', 'a', 'b', 'c', 'b']\n</code></pre> <ul> <li><code>.reverse()</code> : Permet d'inverser l'ordre des éléments d'une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.reverse()\nprint(liste) # Renvoie ['b', 'c', 'b', 'a', 'b', 'a']\n</code></pre> <ul> <li><code>.remove(élément)</code> : Permet de supprimer la première occurence d'un élément dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.remove(\"b\")\nprint(liste) # Renvoie ['a', 'a', 'b', 'c', 'b']\n</code></pre> <ul> <li><code>.sort()</code> : Permet de trier une liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nliste.sort()\nprint(liste) # Renvoie [-5, 1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\nliste2=[\"a\", \"c\", \"b\", \"d\"]\nliste2.sort()\nprint(liste2) # Renvoie ['a', 'b', 'c', 'd']\n</code></pre> <ul> <li><code>max(liste)</code> : Permet de connaitre la valeur maximale d'une liste, <code>min(liste)</code> : Permet de connaitre la valeur minimale d'une liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nprint(max(liste)) # Renvoie 9\nprint(min(liste)) # Renvoie -5\n</code></pre> <ul> <li><code>sum(liste)</code> : Permet de calculer la somme de tout les éléments de la liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nprint(sum(liste)) # Renvoie 34\n</code></pre>","path":["1ère année","Cours","TP 3 - Listes"],"tags":[]},{"location":"1ere/TP3/#divers","level":2,"title":"Divers","text":"<ul> <li>On peut générer des listes grâce à des boucles <code>for</code>:</li> </ul> <pre><code>liste=[i for i in range(10)]\nprint(liste) # Renvoie [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nliste=[i for i in range(10) if i%2==0]\nprint(liste) # Renvoie [0, 2, 4, 6, 8]\nabscisse=[0, 1, 2, 3, 4, 5, 6, 7 ]\nordonnée=[ 3*x+5 for x in abscisse] # Images des éléments de abscisse par la fonction x ↦ 3*x+5\nprint(ordonnée) # Renvoie [5, 8, 11, 14, 17, 20, 23, 26]\n</code></pre> <ul> <li>Copie des listes et effet de bord</li> </ul> <p>En Python, lorsqu'on affecte une liste à une autre variable avec =, cela ne crée pas une nouvelle liste mais une référence vers la même liste. Toute modification de l'une affectera donc l'autre.</p> <pre><code>liste_a = [1, 2, 3]\nliste_b = liste_a  # liste_b référence la même liste que liste_a\nliste_b.append(4)\n\nprint(liste_a)  # Renvoie [1, 2, 3, 4]\nprint(liste_b)  # Renvoie [1, 2, 3, 4]\n</code></pre> <p>Pour éviter cet effet de bord, on peut utiliser la méthode <code>.copy()</code>, <code>list()</code>, ou le slicing <code>[:]</code> afin de créer une vraie copie indépendante de la liste :</p> <pre><code>liste_a = [1, 2, 3]\n\n# Copie indépendante de liste_a\nliste_b = liste_a.copy()  \nliste_c = list(liste_a)\nliste_d = liste_a[:]  # Slicing\n\nliste_b.append(4)\nprint(liste_a)  # Renvoie [1, 2, 3] (liste_a n'a pas été modifiée)\nprint(liste_b)  # Renvoie [1, 2, 3, 4]\nprint(liste_c)  # Renvoie [1, 2, 3]\nprint(liste_d)  # Renvoie [1, 2, 3]\n</code></pre>","path":["1ère année","Cours","TP 3 - Listes"],"tags":[]},{"location":"1ere/TP4/","level":1,"title":"TP 4 - Fonctions","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p> <p>L'instruction <code>def</code> permet de définir une fonction. Cela permet d'éviter de réécrire le même code à plusieurs endroits dans un programme et de réutiliser aisément des morceaux de code. On peut ainsi appeler la fonction à tout moment dans le programme.</p>","path":["1ère année","Cours","TP 4 - Fonctions"],"tags":[]},{"location":"1ere/TP4/#definir-une-fonction","level":2,"title":"Définir une fonction","text":"<p>Pour créer une fonction, on utilise le mot-clé <code>def</code> suivi du nom de la fonction, de ses paramètres entre parenthèses, et d’un deux-points. Le corps de la fonction est indenté. Par exemple :</p> <pre><code>def fonction(x):\ny = x**2\nreturn y\nreturn \"patate\"  # Cette ligne ne sera jamais exécutée\n</code></pre> <p>Attention : dès qu'un <code>return</code> est rencontré, la fonction se termine. Ici, le second <code>return</code> ne sera jamais atteint.</p>","path":["1ère année","Cours","TP 4 - Fonctions"],"tags":[]},{"location":"1ere/TP4/#differentes-formes-usuelles-de-fonctions","level":2,"title":"Différentes formes usuelles de fonctions","text":"<ul> <li>Procédures</li> </ul> <p>Une fonction qui n'utilise pas de <code>return</code> est appelée une procédure. Elle sert principalement à exécuter des instructions (par exemple, afficher des résultats) sans renvoyer de valeur.</p> <pre><code>def affiche_message():\nprint(\"Bonjour\")\n</code></pre> <ul> <li>Fonctions avec conditions</li> </ul> <p>On peut intégrer des conditions dans une fonction pour modifier son comportement en fonction des valeurs d'entrée :</p> <pre><code>def signe(x):\nif x &gt; 0:\n    return \"positif\"\nelif x &lt; 0:\n    return \"négatif\"\nelse:\n    return \"nul\"\n</code></pre> <ul> <li>Fonctions avec plusieurs arguments</li> </ul> <p>Les fonctions peuvent prendre plusieurs paramètres, ce qui permet de travailler sur plusieurs valeurs à la fois :</p> <pre><code>def somme(a, b, c):\nreturn a + b + c\n</code></pre> <ul> <li>Fonctions appelant d’autres fonctions</li> </ul> <p>Une fonction peut faire appel à une autre pour réaliser une tâche plus complexe :</p> <pre><code>def carre(x):\nreturn x**2\n\ndef somme_des_carres(a, b):\nreturn carre(a) + carre(b)\n</code></pre> <ul> <li>Fonctions récursives</li> </ul> <p>Une fonction récursive s'appelle elle-même pour résoudre un problème en le décomposant en sous-problèmes plus simples. Il est essentiel de prévoir une condition d'arrêt pour éviter une récursion infinie.</p> <p>Quelques exemples : <pre><code>def factorielle(n):\nif n == 0:\n    return 1\nelse:\n    return n * factorielle(n - 1)\n</code></pre></p> <pre><code>def fibonacci(n):\nif n == 0:\n    return 0\nelif n == 1:\n    return 1\nelse:\n    return fibonacci(n - 1) + fibonacci(n - 2)\n</code></pre> <pre><code>def puissance(x, n):\n\"\"\"\nCalcul de la puissance n-ième d’un réel x.\n\"\"\"\nif n == 0:\n    if x == 0:\n        print(\"impossible\")\n    else:\n        return 1\nelif n % 2 == 0:\n    y = puissance(x, n // 2) ** 2\nelse:\n    y = x * puissance(x, n - 1)\nreturn y\n\nx = eval(input(\"Entrer le réel x : \"))\nn = eval(input(\"Entrer la puissance entière positive n : \"))\nprint(puissance(x, n))\n</code></pre> <pre><code>def u(n):\n\"\"\"\nCalcule le n-ième terme de la suite définie par :\nU_0 = 1\nU_n = (U_{n-1} + 1) / (U_{n-1} + 2)\n\"\"\"\nif n == 0:\n    return 1\n# Appel récursif :\nu_prec = U(n - 1)\nreturn (u_prec + 1) / (u_prec + 2)\n</code></pre> <pre><code>def count_digits(n):\n\"\"\"\nRenvoie le nombre de chiffres qui composent l'entier n.\nOn utilise la division euclidienne par 10 pour retirer le dernier chiffre.\n\"\"\"\nn = abs(n) # On travaille avec la valeur absolue pour gérer les nombres négatifs\n\nif n &lt; 10:\n    return 1 # Cas de base : s'il n'y a qu'un seul chiffre, on renvoie 1.\n\nelse:\n    return 1 + count_digits(n // 10)# Appel récursif : on enlève le dernier chiffre et on ajoute 1 au résultat.\n\n# Exemples de test :\nprint(count_digits(5))      # Affiche 1\nprint(count_digits(1234))   # Affiche 4\nprint(count_digits(0))      # Affiche 1\nprint(count_digits(-98765)) # Affiche 5\n</code></pre>","path":["1ère année","Cours","TP 4 - Fonctions"],"tags":[]},{"location":"1ere/TP5/","level":1,"title":"TP 5 - Matrices avec Numpy","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p>","path":["1ère année","Cours","TP 5 - Matrices avec Numpy"],"tags":[]},{"location":"1ere/TP5/#creation-de-matrices","level":2,"title":"Création de matrices","text":"<p>Pour créer une matrice, il faut utiliser la fonction <code>array</code> de la bibliothèque <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Renvoie [[1 2 3] [4 5 6] [7 8 9]]\nprint(matrice)\n</code></pre> <pre><code>from numpy import *\nmatrice=array([[1, 2, 3], [4, 5, 6]])\nprint(matrice) # Renvoie [[1 2 3] [4 5 6]]\n</code></pre> <p>Sur python, il est possible de revenir à la ligne entre les différents objets d'une liste, afin de rendre la liste ou matrice plus lisible.</p> <pre><code>import numpy as np\nmatrice=np.array([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n    ])\nprint(matrice) # Renvoie [[1 2 3] [4 5 6] [7 8 9]]\n</code></pre> <p>Certaines matrices utiles sont générées grâce à des fonctions:</p> <pre><code>import numpy as np\nmatrice0=np.zeros((3, 3))\nprint(matrice0) # Renvoie [[0 0 0] [0 0 0] [0 0 0]]\nmatrice1=np.ones((2, 3))\nprint(matrice1) # Renvoie [[1 1 1] [1 1 1]]\nidentite=np.eye(4)\nprint(identite) # Renvoie [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]]\n</code></pre>","path":["1ère année","Cours","TP 5 - Matrices avec Numpy"],"tags":[]},{"location":"1ere/TP5/#fonctions-et-operations-sur-les-matrices","level":2,"title":"Fonctions et opérations sur les matrices","text":"<p>Pour accéder à un élément d'une matrice, on utilise les crochets <code>[ligne, colonne]</code>, presque comme pour les listes. Il est également possible d'utilises les <code>:</code></p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(matrice[1, 2]) # Renvoie 6\nprint(matrice[1:3]) # Renvoie [[4 5 6] [7 8 9]]\nprint(matrice[1:3, 1:3]) # Renvoie [[5 6] [8 9]]\n</code></pre> <p>Pour connaitre le nombre d'éléments d'une matrice, on utilise la fonction <code>size</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(np.size(matrice)) # Renvoie 6\n</code></pre> <p>Pour connaitre le nombre de lignes et de colonnes d'une matrice, on utilise la fonction <code>shape</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(np.shape(matrice)) # Renvoie (2, 3)\n</code></pre> <p>Pour multiplier une matrice par une deuxième matrice, on utilise la fonction <code>dot</code> de <code>numpy</code>, ou l'opérateur <code>@</code> à partir de Python 3.5.</p> <pre><code>import numpy as np\nmatrice1=np.array([[1, 2, 3], [4, 5, 6]])\nmatrice2=np.array([[1, 2], [3, 4], [5, 6]])\nprint(np.dot(matrice1, matrice2)) # Renvoie [[22 28] [49 64]]\nprint(matrice1 @ matrice2) # Renvoie [[22 28] [49 64]]\n</code></pre> <p>Pour faire le produit terme à terme de deux matrices, on utilise l'opérateur <code>*</code>.</p> <pre><code>import numpy as np\nmatrice1=np.array([[1, 2, 3], [4, 5, 6]])\nmatrice2=np.array([[7, 8, 9], [10, 11, 12]])\nprint(matrice1*matrice2) # Renvoie [[7 16 27] [40 55 72]]\n</code></pre> <p>Pour obtenir la transposée d'ue matrice, on utilise la fonction <code>T</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrice.T) # Renvoie [[1 4] [2 5] [3 6]]\n</code></pre> <p>Pour obtenir le déterminant d'une matrice, on utilise la fonction <code>det</code> de <code>numpy.linalg</code>.</p> <pre><code>import numpy as np\nimport numpy.linalg as al\nmatrice22=np.array([[1, 2], [3, 4]])\nprint(al.det(matrice22)) # Renvoie -2.0000000000000004\n                            # (Python à des problèmes au niveau de l'arrondi lors des opérations)\n</code></pre> <pre><code>import numpy as np\nfrom numpy.linalg import *\nmatrice33=np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(det(matrice33)) # Renvoie 0.0\n</code></pre> <p>Pour obtenir l'inverse d'une matrice, on utilise la focntion <code>inv</code> de <code>numpy.linalg</code>.</p> <pre><code>import numpy as np\nmatrice22=np.array([[1, 2], [3, 4]])\nprint(np.linalg.inv(matrice22)) # Renvoie [[-2. 1.], [ 1.5 -0.5]]\n</code></pre>","path":["1ère année","Cours","TP 5 - Matrices avec Numpy"],"tags":[]},{"location":"1ere/TP6/","level":1,"title":"TP 6 - Représentations graphiques avec Matplotlib","text":"<p>Les parties en italique sont des approfondissements qui pourraient être utiles.</p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/TP6/#presentation-de-matplotlib","level":2,"title":"Présentation de Matplotlib","text":"<p>Matplotlib permet de créer des représentations graphiques de données. Il est possible de créer des graphiques en 2D et 3D, des histogrammes, des courbes, etc.</p> <p>Pour importer Matplotlib, il faut utiliser la commande suivante: <pre><code>import matplotlib.pyplot as plt\n</code></pre></p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/TP6/#creation-de-graphiques-simples","level":2,"title":"Création de graphiques simples","text":"<p>Pour créer un graphique simple, il faut utiliser la fonction <code>plot</code> de Matplotlib. Il est possible de personnaliser le graphique en ajoutant des titres, des légendes, des axes, etc.</p> <pre><code>import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\nplt.plot(x, y) # Permet de dessiner la courbe, en reliant les différents points\nplt.title(\"Graphique simple\") # Titre du graphique\nplt.xlabel(\"Axe des X\") # Titre de l'axe des X\nplt.ylabel(\"Axe des Y\") # Titre de l'axe des Y\nplt.show() # Affiche le graphique\n</code></pre> <p></p> <p>On peut aussi utiliser la fonction <code>scatter</code> pour créer un nuage de points. <pre><code>import matplotlib.pyplot as plt\nabscisses = [1, 2, 3, 4, 5]\nordonnees = [2, 3, 5, 7, 11]\nplt.scatter(abscisses, ordonnees) # Permet de dessiner un nuage de points\nplt.title(\"Nuage de points\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/TP6/#personnalisation-de-graphiques","level":2,"title":"Personnalisation de graphiques","text":"<p>Il est possible de personnaliser les graphiques en ajoutant des titres, des légendes, des axes, etc. Il est aussi possible de changer la couleur et le style des lignes.</p> <pre><code>import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\nplt.plot(x, y, color='red', linestyle='--', linewidth=2) # Crée une ligne rouge en pointillés de 2 pixels d'épaisseur\nplt.scatter(x, y, color='blue', marker='o', label=\"Point\") # Ajouter des points ronds sur la ligne\nplt.title(\"Graphique personnalisé\") # Titre du graphique\nplt.xlabel(\"Axe des X\") # Titre de l'axe des X\nplt.ylabel(\"Axe des Y\") # Titre de l'axe des Y\nplt.grid() # Affiche une grille\nplt.legend([\"Ligne rouge\",\n            \"Points de la ligne\"], loc=\"upper left\")\n# Affiche une légende, chaque élément de la liste correspond à un élément du graphique,\n# dans l'ordre du code (plt.plot est en premier dans le code, donc \"Ligne rouge\" est en premier dans la liste)\n\nplt.show() # Affiche le graphique\n</code></pre> <p></p> <p>Il est également possible de créer une légende d'une autre façon: <pre><code>import matplotlib.pyplot as plt\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\nplt.plot(x, y, color='red', linestyle='--', linewidth=2, label=\"Ligne rouge\")\nplt.scatter(x, y, color='blue', marker='o', label=\"Points de la ligne\")\nplt.legend() # On ne met rien dans plt.legend car on a déjà mis les labels dans plt.plot et plt.scatter\nplt.show()\n</code></pre></p> <p></p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/TP6/#generer-des-graphiques-via-des-fonctions","level":2,"title":"Générer  des graphiques via des fonctions","text":"<p>Il faut en premier connaître deux fonctions de <code>numpy</code>: - <code>linspace</code>: permet de créer une matrice de valeurs entre deux bornes, avec un nombre de valeurs donné. Par exemple, <code>numpy.linspace(0, 10, 5)</code> crée une matrice de  5 valeurs entre 0 et 10: <code>[0., 2.5, 5., 7.5, 10.]</code> - <code>arange</code>: permet de créer un tableau de valeurs entre deux bornes, avec un pas donné. Par exemple, <code>numpy.arange(0, 10, 2)</code> crée un tableau de valeurs entre 0 et 10, avec un pas de 2: <code>[0, 2, 4, 6, 8]</code></p> <p>Il faudra choisir entre ces deux fonctions en fonction de ce que l'on veut faire.</p> <p>Ces deux fonction génerent une matrice ligne. Il est donc possible d'utliser les fonctions mathématiques de <code>numpy</code> sur ces matrices. Par exemple, <code>numpy.exp</code> permet de calculer le sinus de chaque valeur de la matrice. <pre><code>import numpy as np\nx = np.linspace(0, 10, 5) # Crée une matrice de 5 valeurs entre 0 et 10\ny = np.exp(x) # Crée une matrice des valeurs de exp(valeur) pour chaque valeur de la matrice x\nprint(y) # Affiche la matrice [1.00000000e+00 1.21824940e+01 1.48413159e+02 1.80804241e+03 2.20264658e+04]\n</code></pre></p> <p>Exemple en utilisant <code>linspace</code> pour la fonction <code>sinus</code>: <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(-2 * np.pi, 2 * np.pi, 100) # Crée un tableau de 100 valeurs entre -2pi et 2pi\ny = np.sin(x) # Crée un tableau de 100 valeurs entre -1 et 1\nplt.plot(x, y)\nplt.title(\"Sinus\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p> <p>Exemple en utilisant <code>arange</code> pour la fonction <code>log</code>: <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0.01, 10, 0.1) # Crée un tableau de valeurs entre 0.01 et 10, avec un pas de 0.1\ny = np.log(x) # Crée un tableau de valeurs entre 0 et 2.3\nplt.plot(x, y)\nplt.title(\"Logarithme\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/TP6/#exemples","level":2,"title":"Exemples","text":"<p>Voir Révisions sur les fonctions.ipynb.</p> <p>Fiche de l'Académie de Versailles (donnée par la prof): Fiche PDF</p> <p>Lien vers le fichier sur le site de l'Académie de Versailles: https://phychim.ac-versailles.fr/IMG/pdf/tuto_python_matplotlib.pdf</p>","path":["1ère année","Cours","TP 6 - Représentations graphiques avec Matplotlib"],"tags":[]},{"location":"1ere/Toutes_les_fonctions_de_1ere_annee/","level":1,"title":"Toutes les fonctions de 1ère année","text":"<p>Télécharger le fichier</p> <pre><code>import numpy as np\nimport math\nimport fractions\nimport random as rd\nimport matplotlib.pyplot as plt\n\n\nabs\nmin\nmax\nsum\nround\nint\nfloat\nstr\nbool\nlist\ninput\neval\nprint\nlen\nlist.append\nlist.copy\nlist.index\nlist.count\nlist.pop\nlist.remove\nlist.reverse\nlist.sort\nlist.insert\n\nnp.exp\nnp.log\nnp.log2\nnp.log10\nnp.pi\nnp.arange\nnp.linspace\nnp.size\nnp.shape\nnp.array\nnp.dot\nnp.eye\nnp.ones\nnp.zeros\nnp.array(...).T\nnp.linalg.det\nnp.linalg.inv\n\nmath.factorial\nmath.log\nmath.log2\nmath.log10\nmath.pi\nmath.exp\nmath.sqrt\nmath.sin\nmath.cos\nmath.tan\nmath.floor\nmath.ceil\n\nfractions.Fraction\nfractions.Fraction(...).numerator\nfractions.Fraction(...).denominator\n\nrd.random\nrd.randint\nrd.choice # Pas dans le programme mais très utile, permet de choisir un élément au hasard dans une liste\n\nplt.plot\nplt.scatter\nplt.bar\nplt.title\nplt.xlabel\nplt.ylabel\nplt.grid\nplt.legend\nplt.show\n</code></pre>","path":["1ère année","Ressources","Toutes les fonctions de 1ère année"],"tags":[]},{"location":"2eme/","level":1,"title":"Cours d'informatique de 2ème année","text":"","path":["2ème année","Cours d'informatique de 2ème année"],"tags":[]},{"location":"2eme/#sommaire","level":2,"title":"Sommaire","text":"<ul> <li> <p>Correction des TP:</p> <ul> <li>Correction de la Feuille 1</li> <li>Correction de la Feuille 2</li> <li>Correction de la Feuille 3</li> </ul> </li> <li> <p>Ressources:</p> <ul> <li>Mémo Python</li> </ul> </li> <li> <p>DS avec sujet et correction:</p> <ul> <li>DS1 2024</li> <li>DS1 2023</li> </ul> </li> </ul>","path":["2ème année","Cours d'informatique de 2ème année"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/","level":1,"title":"Nouvelles fonctions","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npmean","level":2,"title":"np.mean","text":"<p>Compute the arithmetic mean along the specified axis.</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npcumsum","level":2,"title":"np.cumsum","text":"<p>Return the cumulative sum of the elements along a given axis.</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npmedian","level":2,"title":"np.median","text":"<p>Compute the median along the specified axis.</p> <p>Returns the median of the array elements.</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npvar","level":3,"title":"np.var","text":"<p>Compute the variance along the specified axis.</p> <p>Returns the variance of the array elements, a measure of the spread of a distribution.</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npstd","level":3,"title":"np.std","text":"<p>Compute the standard deviation along the specified axis.</p> <p>Returns the standard deviation, a measure of the spread of a distribution, of the array elements.</p> <p>import numpy.linalg as al</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#alinv","level":3,"title":"al.inv","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#alrank","level":3,"title":"al.rank","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#almatrix_power","level":3,"title":"al.matrix_power","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#alsolve","level":3,"title":"al.solve","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#aleig","level":3,"title":"al.eig","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdrandom","level":3,"title":"rd.random","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdbinomial","level":3,"title":"rd.binomial","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdrandint","level":3,"title":"rd.randint","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdgeometric","level":3,"title":"rd.geometric","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdpoisson","level":3,"title":"rd.poisson","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdexponential","level":3,"title":"rd.exponential","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdnormal","level":3,"title":"rd.normal","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#rdgamma","level":3,"title":"rd.gamma","text":"<p>import scipy.special as sp</p>","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#spndtr","level":3,"title":"sp.ndtr","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#plthist","level":3,"title":"plt.hist","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#pltcontour","level":3,"title":"plt.contour","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#npmeshgrid","level":3,"title":"np.meshgrid","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/Nouvelles%20fonctions/#pltquiver","level":3,"title":"plt.quiver","text":"","path":["Nouvelles fonctions"],"tags":[]},{"location":"2eme/DS/DS1_2023/","level":1,"title":"DS Info – ECG 2 (2023–2024)","text":"<p>A. BENADDI Lycée Kléber</p> <p>La correction se trouve à la fin du sujet.</p> <p>Pour tout le DS, nous importerons les librairies :</p> <pre><code>from math import *\nimport numpy as np\nimport numpy.random as rd\nimport matplotlib.pyplot as plt\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-1","level":2,"title":"Exercice 1","text":"<p>Soit \\((u_n)_n\\) une suite convergente définie par :</p> \\[ u_n = \\sum_{k=1}^n \\frac{1}{k} - \\ln(n) \\] <ol> <li> <p>Écrire une fonction Python <code>u</code> qui prend en argument un entier naturel \\(n\\) non nul et qui renvoie la valeur de \\(u_n\\).</p> </li> <li> <p>On admet que</p> </li> </ol> \\[ \\exists \\gamma, \\text{ tel que } \\forall n \\in \\mathbb{N}^*, \\gamma \\le u_n \\quad \\text{et} \\quad |u_n - \\gamma| \\le \\frac{1}{n}. \\] <p>En utilisant la fonction <code>u</code>, écrire un programme en Python pour qu’il donne en sortie la valeur approchée de la limite de la suite \\((u_n)\\) à \\(\\varepsilon\\) près, où \\(\\varepsilon\\) est un réel assez petit, donné par l’utilisateur.</p>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-2","level":2,"title":"Exercice 2","text":"<p>On pose :</p> \\[ A = \\begin{pmatrix} 1 &amp; 1 &amp; 1 \\\\ 1 &amp; 2 &amp; 1 \\\\ 1 &amp; 1 &amp; 3 \\end{pmatrix} \\] <p>La matrice \\(A\\) est inversible et</p> \\[ g(x) = \\frac{1}{x+1} + \\frac{1}{x-1} + \\frac{1}{x-2}, \\quad \\text{pour tout } x \\in \\mathbb{R} \\setminus {-1,1,2}. \\] <p>On note \\(\\alpha\\) la plus grande valeur propre de \\(A\\), telle que \\(4 &lt; \\alpha &lt; 5\\), solution de l’équation \\(g(x)=1\\).</p> <p>Recopier et compléter les lignes incomplètes de la fonction Python afin qu’elle renvoie une valeur approchée de \\(\\alpha\\) à \\(10^{-3}\\) près à l’aide de la méthode de dichotomie.</p> <pre><code># valeur approchee\nx, y = 4, 5\nwhile ...:\n    m = ...\n    if ...:\n        ...\n    else:\n        ...\nreturn alpha\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-3","level":2,"title":"Exercice 3","text":"<p>Dans cet exercice, toutes les variables aléatoires sont supposées définies sur un même espace probabilisé \\((\\Omega, \\mathcal{A}, \\mathbb{P})\\).</p> <p>On considère une urne contenant initialement une boule bleue et une boule rouge. On procède à des tirages successifs d’une boule au hasard selon le protocole suivant :</p> <ul> <li>si on obtient une boule bleue, on la remet dans l’urne et on ajoute une boule bleue supplémentaire ;</li> <li>si on obtient une boule rouge, on ne la remet pas dans l’urne et on arrête l’expérience.</li> </ul> <p>On suppose que toutes les boules sont indiscernables au toucher et on admet que l’expérience s’arrête avec une probabilité égale à \\(1\\).</p> <p>On note \\(N\\) la variable aléatoire égale au nombre de boules présentes dans l’urne à la fin de l’expérience.</p>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#a","level":3,"title":"a)","text":"<p>On montre que :</p> \\[ \\forall n \\in \\mathbb{N} \\setminus {0,1}, \\quad \\mathbb{P}(N=n) = \\frac{1}{n(n-1)} \\] <p>et que la variable aléatoire \\(N\\) n’admet pas d’espérance.</p> <p>Écrire une fonction Python d’entête <code>def simuleN():</code> de façon à ce qu’elle renvoie une simulation de la variable aléatoire \\(N\\).</p> <p>On considère une suite \\((X_n)_{n \\in \\mathbb{N}}\\) de variables aléatoires indépendantes et de même loi. On suppose que, pour tout \\(n \\in \\mathbb{N}^*\\), les variables aléatoires \\(X_1, \\ldots, X_n\\) et \\(N\\) sont mutuellement indépendantes.</p> <p>On définit la variable aléatoire</p> \\[ T = \\max(X_1, \\ldots, X_N), \\] <p>ce qui signifie :</p> \\[ \\forall \\omega \\in \\Omega, \\quad T(\\omega) = \\max(X_1(\\omega), \\ldots, X_N(\\omega)). \\] <p>Ainsi par exemple :</p> <ul> <li>si \\(N\\) prend la valeur \\(3\\), alors \\(T = \\max(X_1, X_2, X_3)\\) ;</li> <li>si \\(N\\) prend la valeur \\(5\\), alors \\(T = \\max(X_1, X_2, X_3, X_4, X_5)\\) ; etc.</li> </ul> <p>On suppose que, pour tout \\(n \\in \\mathbb{N}\\), la variable aléatoire \\(X_n\\) suit la loi uniforme sur \\([0,1]\\).</p> <p>On rappelle que l’instruction <code>rd.random()</code> renvoie une matrice \\(1 \\times 1\\) dont les coefficients sont des réalisations de variables aléatoires indépendantes suivant la loi uniforme sur \\([0,1]\\).</p>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#b","level":3,"title":"b)","text":"<p>Écrire une fonction Python d’entête <code>def simuleT():</code> qui renvoie une simulation de la variable aléatoire \\(T\\).</p>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#c","level":3,"title":"c)","text":"<p>En notant \\((T_1, \\ldots, T_m)\\) un échantillon de la v.a.r. \\(T\\). Compléter la fonction d’entête <code>def EML(m)</code> qui renvoie un vecteur ligne à 3 coordonnées contenant chacune une simulation de la moyenne (espérance)</p> \\[ E(T) = \\frac{1}{m} \\sum_{i=1}^m T_i. \\] <pre><code>def EML(m):\n    E = np.zeros(...)\n    for k in ...:\n        echantillon = ...\n        for i in ...:\n            ...\n        ... # Le prof n'a pas mis de pointillés ici sur le sujet mais\n            # il ajoute une ligne dans la correction donc je les ajoute ici.\n    return E\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-4-une-application-probabiliste-de-la-formule-sommatoire-de-poisson","level":2,"title":"Exercice 4 — Une application probabiliste de la formule sommatoire de Poisson","text":"<p>Soit \\(p\\) un réel vérifiant \\(0 &lt; p &lt; 1\\).</p> <p>Deux joueurs \\(A\\) et \\(B\\) lancent tour à tour une pièce de monnaie.</p> <p>Le jet de la pièce donne « Pile » avec la probabilité \\(p\\) et « Face » avec la probabilité \\(1-p\\).</p> <p>Le vainqueur de la partie est le joueur qui obtient « Pile » le premier, auquel cas la partie s’arrête.</p> <p>Le premier lancer (de rang 1) est effectué par le joueur \\(A\\).</p> <p>Si la partie ne s’arrête pas, les trois lancers suivants (de rangs 2, 3 et 4) sont effectués par le joueur \\(B\\), les suivants (de rangs 5, 6, 7, 8 et 9) par le joueur \\(A\\), et ainsi de suite.</p> <p>Après chaque changement de main, le joueur qui reprend la main ne peut ainsi effectuer (au maximum) que deux lancers de plus que ceux que vient d’effectuer l’autre joueur.</p> <p>On suppose que les résultats des lancers successifs sont indépendants.</p> <p>On écrit la fonction Python incomplète suivante :</p> <pre><code>def jeu(p):\n    i, v = 1, 1\n    s, j = 1, 1\n    while ...:\n        i = ...\n        j = ...\n        if j &gt; s:      # changement de main\n            v=-v\n            s = ...\n            j = ...\n    if v == 1:\n        vainqueur = 'A vainqueur'\n    else:\n        vainqueur = 'B vainqueur'\n    return vainqueur\n</code></pre> <ol> <li>Compléter la fonction Python ci-dessus qui simule une partie effectuée selon les règles précédentes et affiche le vainqueur.</li> <li>Que représente la valeur de <code>i</code> après l’exécution de la fonction <code>jeu</code> ?</li> <li>Préciser la signification de la variable <code>v</code>.</li> <li>Compléter le code de la fonction <code>jeu</code> pour qu’elle affiche le nombre de lancers effectués par le joueur \\(A\\).</li> <li>Écrire un code Python permettant d’obtenir une valeur approchée de la probabilité que le vainqueur du jeu soit le joueur \\(A\\). On admet qu’une valeur approchée de la probabilité d’un événement \\(A\\) est la fréquence sur un grand nombre de simulations. On prendra dans le programme le nombre de simulations égal à \\(100000\\).</li> </ol>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#correction-ds-info-ecg2","level":1,"title":"Correction DS Info — ECG2","text":"<p>Pour tout le DS, nous importons les librairies :</p> <pre><code>from math import *\nimport numpy as np\nimport numpy.random as rd\nimport matplotlib.pyplot as plt\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-1-4-points","level":1,"title":"Exercice 1 — 4 points","text":"","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-1-2-points","level":2,"title":"Question 1 — 2 points","text":"<pre><code>def suiteu(n):\n    u = 0\n    for k in range(1, n+1):\n        u = u + 1/k\n    return u - log(n)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-2-2-points","level":2,"title":"Question 2 — 2 points","text":"<pre><code>epsilon = float(input('Donner un réel positif assez petit eps = '))\nn = 1\nwhile 1/n &gt; 2*epsilon:\n    n = n + 1\n\nprint('La valeur approchée de gamma est ', suiteu(n))\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-2-4-points","level":1,"title":"Exercice 2 — 4 points","text":"<pre><code>def valeur_approchee():\n    x, y = 4, 5\n    while abs(x - y) &gt; 0.0001:\n        m = (x + y) / 2\n        if (1/(m+1) + 1/(m-1) + 1/(m-2) - 1) * (1/(x+1) + 1/(x-1) + 1/(x-2) - 1) &lt; 0:\n            y = m\n        else:\n            x = m\n    alpha = m\n    return alpha\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-3-6-points","level":1,"title":"Exercice 3 — 6 points","text":"","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-a-2-points","level":2,"title":"Question a — 2 points","text":"<pre><code>def simuleN():\n    b = 1   # b désigne le nombre de boules bleues dans l’urne\n    N = 2\n    while rd.random() &lt; b/(b+1):\n        b = b + 1\n        N = N + 1\n    return N\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-b-2-points","level":2,"title":"Question b — 2 points","text":"<pre><code>def simuleT():\n    N = simuleN()\n    X = rd.random(N)\n    T = max(X)\n    return T\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-c-2-points","level":2,"title":"Question c — 2 points","text":"<pre><code>def EML(m):\n    E = np.zeros(3)\n    for k in range(3):\n        echantillon = np.zeros(m)\n        for i in range(m):\n            echantillon[i] = simuleT()\n        E[k] = np.mean(echantillon)\n    return E\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#exercice-4-6-points","level":1,"title":"Exercice 4 — 6 points","text":"","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-1-15-points","level":2,"title":"Question 1 — 1,5 points","text":"<pre><code>def jeu(p):\n    i = 1\n    v = 1\n    s, j = 1, 1\n    while rd.random() &gt; p:\n        i = i + 1\n        j = j + 1\n        if j &gt; s:\n            v = -v      # changement de main\n            s = s + 2\n            j = 1\n    if v == 1:\n        vainqueur = 'A vainqueur'\n    else:\n        vainqueur = 'B vainqueur'\n    return vainqueur\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-2-05-point","level":2,"title":"Question 2 — 0,5 point","text":"<p><code>i</code> représente le nombre de lancers effectués depuis le début de la partie jusqu’à ce que le jeu s’arrête.</p>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-3-05-point","level":2,"title":"Question 3 — 0,5 point","text":"<p>La variable <code>v</code> permet un changement de joueur au cours du jeu, donc permet de déterminer le vainqueur de la partie.</p> <ul> <li>si <code>v = 1</code>, le vainqueur est \\(A\\) ;</li> <li>si <code>v = -1</code>, le vainqueur est \\(B\\).</li> </ul>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-4-15-points","level":2,"title":"Question 4 — 1,5 points","text":"<pre><code>def jeu_nb_A(p):\n    i = 1\n    v = 1\n    s, j = 1, 1\n    nb_lancers_A = 1   # initialisation\n    while rd.random() &gt; p:\n        i = i + 1\n        j = j + 1\n        if j &gt; s:\n            v = -v      # changement de main\n            s = s + 2\n            j = 1\n        if v == 1:\n            nb_lancers_A = nb_lancers_A + 1\n    if v == 1:\n        vainqueur = 'A vainqueur'\n    else:\n        vainqueur = 'B vainqueur'\n    return vainqueur, nb_lancers_A\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2023/#question-5-2-points","level":2,"title":"Question 5 — 2 points","text":"<pre><code>N = 100000\nf = 0\np = float(input(\"Entrer la probabilité d’avoir Pile comprise entre 0 et 1, p = \"))\n\nfor k in range(N):\n    if jeu(p) == 'A vainqueur':\n        f = f + 1\n\nprint('La valeur approchée de la probabilité que le vainqueur du jeu soit le joueur A est P(A) = ', f/N)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2023–2024)"],"tags":[]},{"location":"2eme/DS/DS1_2024/","level":1,"title":"DS Info – ECG 2 (2024–2025)","text":"<p>A. BENADDI Lycée Kléber</p> <p>La correction se trouve à la fin du sujet.</p> <p>Pour tout le DS, nous importerons les librairies :</p> <pre><code>from math import *\nimport numpy as np\nimport numpy.random as rd\nimport matplotlib.pyplot as plt\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-1","level":2,"title":"Exercice 1","text":"<p>Pour tout \\(n \\in \\mathbb{N}^*\\), on pose :</p> \\[ S_n = \\sum_{k=1}^{n} \\frac{1}{k^2} \\quad \\text{et} \\quad S = \\sum_{k=1}^{+\\infty} \\frac{1}{k^2} \\] <p>tel que l’on a l’encadrement suivant pour tout \\(n \\in \\mathbb{N}^*\\) :</p> \\[ S_n + \\frac{1}{n+1} + \\frac{1}{2(n+1)^2} \\;\\leq\\; S \\;\\leq\\; S_n + \\frac{1}{n} + \\frac{1}{2(n+1)^2} \\]","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#1","level":3,"title":"1)","text":"<p>Compléter la ligne d’instruction en Python qui permet de calculer la somme \\(S_n\\), pour un entier donné par l’utilisateur :</p> <pre><code>Sn = sum(.......................)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#2","level":3,"title":"2)","text":"<p>Écrire un programme Python qui affiche une valeur approchée de \\(S\\) à \\(10^{-4}\\) près et le nombre d’itérations nécessaires pour atteindre cette approximation.</p>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-2","level":2,"title":"Exercice 2","text":"<p>Pour toutes suites numériques \\(u = (u_n)_{n \\in \\mathbb{N}}\\) et \\(v = (v_n)_{n \\in \\mathbb{N}}\\), on définit la suite \\(w\\) par :</p> \\[ \\forall n \\in \\mathbb{N}, \\quad w_n = \\sum_{k=0}^{n} u_k\\, v_{n-k} \\] <p>On suppose que les suites \\(u\\) et \\(v\\) sont définies par :</p> \\[ \\forall n \\in \\mathbb{N}, \\quad u_n = \\ln(n+1) \\quad \\text{et} \\quad v_n = \\frac{1}{n+1} \\] <p>Écrire un programme en Python qui demande à l’utilisateur une valeur de l’entier naturel \\(n\\), qui calcule et affiche les valeurs de :</p> \\[ w_0, w_1, \\ldots, w_n \\]","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-3","level":2,"title":"Exercice 3","text":"<p>On s’intéresse dans cet exercice à la série :</p> \\[ \\sum_{n \\in \\mathbb{N}} \\frac{(-1)^{n+1}}{n^x}, \\quad \\text{pour tout } x \\in \\mathbb{R}. \\] <p>On admet que pour tout \\(x \\in \\mathbb{R}^-\\), la série :</p> \\[ \\sum_{n \\in \\mathbb{N}} \\frac{(-1)^{n+1}}{n^x} \\] <p>diverge.</p> <p>Soit \\(x \\in \\mathbb{R}^{+*}\\), on note, pour tout \\(n \\in \\mathbb{N}^*\\) :</p> \\[ u_n = \\sum_{k=1}^{n} \\frac{(-1)^{k+1}}{k^x}. \\] <p>On admet aussi que :</p> <ul> <li> <p>(a) Les suites \\((u_{2p})_{p \\in \\mathbb{N}}\\) et \\((u_{2p+1})_{p \\in \\mathbb{N}}\\)   sont adjacentes et convergent vers une même limite notée \\(S(x)\\).</p> </li> <li> <p>(b) \\(\\forall \\varepsilon &gt; 0\\), il existe \\(n_0 \\in \\mathbb{N}^*\\) tel que \\(\\forall n \\geq n_0\\), \\(|u_n - S(x)| \\leq \\varepsilon\\).</p> </li> </ul> <p>(c) La série</p> \\[ \\sum_{n \\in \\mathbb{N}^*} \\frac{(-1)^{n+1}}{n^x} \\] <p>converge et l’on a :</p> \\[ S(x) = \\sum_{k=1}^{+\\infty} \\frac{(-1)^{k+1}}{k^x}. \\] <ul> <li>(d) \\(\\forall p \\in \\mathbb{N}^*\\) :</li> </ul> \\[ u_{2p} \\leq S(x) \\leq u_{2p+1} \\leq u_{2p-1}. \\] <ul> <li>(e) \\(\\forall n \\in \\mathbb{N}^*\\) :</li> </ul> \\[ |u_n - S(x)| \\leq \\frac{1}{(n+1)^x}. \\] <p>En utilisant ce qui précède, écrire une fonction en Python qui, étant donnés deux réels \\(x &gt; 0\\) et \\(\\varepsilon &gt; 0\\), renvoie une valeur approchée de \\(S(x)\\) à \\(\\varepsilon\\) près.</p>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-4","level":2,"title":"Exercice 4","text":"<p>L’urne U1 contient \\(N\\) boules :</p> <ul> <li>\\((N - 1)\\) boules blanches  </li> <li>\\(1\\) boule noire  </li> </ul> <p>On effectue des tirages sans remise dans l’urne U1 jusqu’à l’obtention de la boule noire. On note \\(X\\) la variable aléatoire qui prend pour valeur le nombre de tirages nécessaires pour l’obtention de la boule noire.</p>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#1_1","level":3,"title":"1)","text":"<p>On simule 10000 fois cette expérience aléatoire. Recopier et compléter le programme Python suivant pour qu’il affiche un vecteur, dont les composantes sont les fréquences d’apparition du rang d’obtention de la boule noire :</p> <pre><code>N = int(input('Donner un entier naturel non nul'))\nS = np.zeros(N)\n\nfor k in range(10000):\n    i = 1\n    M = ...  # La variable M désigne le nombre de boules contenues dans l’urne\n    while ... :\n        i = ...\n        M = ...\n    S[...] = ...\n\nprint(...)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#2_1","level":3,"title":"2)","text":"<p>On exécute le programme complété ci-dessus. On entre 5 au clavier et on obtient l’histogramme suivant :</p> <p></p> <p>Quelle conjecture pouvez-vous émettre sur la loi de la variable aléatoire \\(X\\) ?</p>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#correction-ds","level":1,"title":"Correction DS","text":"","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#les-modules-necessaires-pour-le-ds","level":2,"title":"Les modules nécessaires pour le DS","text":"<pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom math import *\nimport numpy.random as rd\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-1_1","level":2,"title":"Exercice 1","text":"","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#question-1","level":3,"title":"Question 1","text":"<pre><code>S_n = np.sum([1/k**2 for k in range(1, n+1)])\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#question-2","level":3,"title":"Question 2","text":"<pre><code>n = 1\nwhile 1/n - 1/(2*(n+1)**2) &gt; 0.0001:\n    n = n + 1\n\nS_n = np.sum([1/k**2 for k in range(1, n+1)])\nprint(\"la valeur approchée de S est :\", S_n)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-2_1","level":2,"title":"Exercice 2","text":"<pre><code>n = int(input(\"n = \"))\nw = 0\nprint(\"w0 =\", w)\n\nfor k in range(1, n+1):\n    w = w + log(k+1)/(n-k+1)\n    print(\"w\", k, \"=\", w)\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-3_1","level":2,"title":"Exercice 3","text":"<p>D’après la question e), il suffit que :</p> \\[ \\frac{1}{(n+1)^x} \\leq \\varepsilon \\iff n \\geq \\frac{1}{\\varepsilon^{1/x}} - 1 \\] <p>pour que \\(u_n\\) soit une valeur approchée de \\(S(x)\\) à \\(\\varepsilon\\) près, ce qui conduit au script suivant :</p> <pre><code>def evalS(x, eps):\n    u = 0\n    for k in range(1, floor(1/eps**(1/x))):\n        u = u + (-1)**(k+1) / k**x\n    return u\n</code></pre>","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/DS/DS1_2024/#exercice-4_1","level":2,"title":"Exercice 4","text":"<p>Dans ce programme, la variable M désigne le nombre de boules contenues dans l’urne (qui diminue au fil de l’expérience).</p> <p>Donc, à chaque tirage, la probabilité de tirer la boule noire est :</p> \\[ \\frac{1}{M}. \\] <pre><code>N = int(input(\"Donner un entier naturel non nul\"))\nS = np.zeros(N)\n\nfor k in range(10000):\n    i = 1\n    M = N\n    while rd.random() &gt; 1/M:\n        i = i + 1\n        M = M - 1\n    S[i-1] = S[i-1] + 1 # Le prof a mis S[i]=S[i]+1 mais ca ne marche\n                        # pas car la liste commence avec l'indice 0\n                        # alors que notre i commence à 1.\n\nprint(S/10000)\n</code></pre> <p>On sait tout d’abord que :</p> \\[ X(\\Omega) = \\{1, 2, 3, 4, 5\\}. \\] <p>D’après l’histogramme donné, il semble que la variable aléatoire \\(X\\) suive une loi uniforme sur :</p> \\[ \\{1, \\ldots, 5\\}. \\]","path":["2ème année","DS","DS Info – ECG 2 (2024–2025)"],"tags":[]},{"location":"2eme/Feuille1/Feuille1/","level":1,"title":"TP1 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger la correction du prof</p>","path":["2ème année","TP","TP1 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille1/Feuille1/#correction-du-prof","level":3,"title":"Correction du prof :","text":"<pre><code># Merci à Bérénice pour avoir recopié la correction du prof\n#\n# Date de dernière mise à jour de la correction: 03.09.2025\n# ===========================================================\n\n\nimport numpy as np  # pour calcul matriciel\nimport matplotlib.pyplot as plt  #ma biblio pour la représenta graphique en 2D\nfrom math import*\n\n#Exo 1\n\n#1) Correction\n\n#version1\nn=int(input('Donner un entier naturel n:'))\nL=[k**3 for k in range (n+1)]\nS=sum(L)\nprint(\"La liste L est\",L,\"et la somme est\",S)\n\n\n#version 2\n\nn=int(input('Donner un entier naturel n:'))\nL=[]  #liste vide\ns=0\nfor k in range(n+1):\n    L=L+[k**3]  #construction d'une liste à l'aide d'une concaténation\n    s=s+k**3  # calcul de la somme\n\n#2)  Correction\n\n#version 1\n\ndef inverse1(L):\n    M=[1/k for k in L if k!=0]\n    return M\n\n#version 2\n\ndef inverse2(L):\n    L_inv=[]\n    for k in L:\n        if k!=0:\n            L_inv.append(1/k)\n    return L_inv\n\n\n#3)\n\n#version 1\nn=int(input('le nmbre de notes est:'))\nnotes=[]\nlistecoeffs=[]  #initialisation de la liste\nSprod=0  #initialisation de la somme\nScoeffs=0\nfor k in range(n):\n    print('note', k+1,' :')\n    note=float(input(' '))\n    print('Coef', k+1, ' :')\n    coeff=float(input(' '))\n    Scoeffs= Scoeffs+coeff\n    Sprod= Sprod+note*coeff\nprint(\"La moyenne est \", Sprod/Scoeffs)\n\n\n#version 2\n\nnotes= eval(input('donner la liste des notes:'))\nlistecoeffs=eval(input('Donner la liste des coefs:'))\nS=0\nfor k in range (len(notes)):\n    S=S+notes[k]*listecoeffs[k]\n    M=S/sum(listecoeffs)\nprint(\"La moyenne est\", M)\n\n\n#4)\n\ndef echange(L,i,j):\n    if 0&lt;=i&lt;=len(L)-1 and 0&lt;=j&lt;=len(L)-1:\n        #les indices vont de 0 à longueur -1\n        L[i], L[j]=L[j],L[i]\n    else:\n        L='changer i ou j'\n    return L\n\n\n\ndef echange2(L,i,j):\n    if 0 &lt;=i&lt;=len(L)-1 and 0&lt;=j&lt;=len(L)-1:\n        X=L[i]\n        L[i]=L[j]\n        L[j]=X\n    else:\n        L=\"changer l'un des argument-s i ou j\"\n    return L\n\n##5)\n\ndef supp1(L,x):\n    L1=[y for y in L if y!=x]\n    return L1\n\n# ou\n\ndef supp2(L,x):\n    L2=[]\n    for k in range (0,len(L)):\n        if L[k]!=x:\n            L2.append(L[k])\n    return L2\n\ndef supp3(L,x):\n    L3=[]\n    for l in L:\n        if l!=x:\n            L3=L3+[l]\n    return L3\n\n##6\n\ndef insertion(L,i,x):\n    if 0&lt;=i&lt;=len(L)-1:\n\n       L1=L[0:i]   #extraction d'une liste de 0 à i-1\n       L2=L[i:len(L)]   #extraction d'une liste de i à longueur -1\n       L=L1+[x]+L2\n    else:\n        L=\"l'indice i n'appartient à l'intervalle\"\n    return L\n\ndef insertion2(L,i,x):\n    if 0&lt;=i&lt;=len(L)-1:\n        L.insert(i,x)\n    else:\n        L=\"l'indice i n'appartient à l'intervalle\"\n    return L\n\n##7\ndef mesmax1(L):\n    maxi=max(L)\n    return maxi, L.count(maxi)\n\ndef mesmax2(L):\n    maxi=L[0] #on suppose que le 1er terme est le max\n    c=0\n    for x in L:\n        if x&gt;maxi:\n            maxi=x\n            c=1\n        elif x==maxi:\n            c=c+1\n    return maxi, c\n\n\n##8\n\ndef supdouble(L):\n    NL=[]\n    for x in L:\n        if x not in NL:\n            NL=NL+[x]\n    return NL\n\n##9\n\ndef appro(L):\n    ecart=abs(L[0]-L[1])\n    a,b=L[0], L[1]\n    for i in range(0,len(L)):\n        for j in range (i+1, len(L)):\n            if abs(L[i]-L[j]) &lt;ecart:\n                ecart=abs(L[i]-L[j])\n                a,b=L[i], L[j]\n    return a,b\n\n\n##10\n\nn=int(input(\"n?\"))\nL=[i+j for i in range(0,n) for j in range (i+1, n+1)]\nprint('sommeV1', sum(L))\n\n\nn=int(input(\"n?\"))\nS=0\nfor i in range (0,n):\n    for j in range(i+1,n+1):\n        S=S+i+j\nprint('sommev2=',S)\n\ndef sommedouble(n):\n    s=0\n    for i in range (0,n):\n        for j in range (i+1,n+1):\n            s=s+i+j\n    return 'sommev3=',s\n\n\n\n#exercice 1\n\n\ndef factorielle(n):\n    P=1\n    for k in range(1,n+1):\n        P=P*k\n    return P\nx=range(0,50) #axe des abcisse\nu=[factorielle(n)/n**n for n in x]\nplt.plot(x,u, 'xg')\nplt.show()\n\n\nn=int(input('N?'))\nP=1\nu=[]\nfor k in range(1,n+1):\n    P=P*k\n    u.append(P/k**k)\nx=range(0,n) #axe des abcisses\nplt.plot(x,u,'*r')\nplt.show()\n\n\n #exercice 2\n\ndef f(n,x):\n    y=x**n+x-1\n    return y\n\ndef dicho(n):\n    a,b=0,1\n    while abs(b-a)&gt;10**(-3):\n        m=(a+b)/2\n        if f(n,m)==0:\n            a,b= m,m\n        elif f(n,a)*f(n,m)&lt;0:\n            b=m\n        elif f(n,a)*f(n,m)&gt;0:\n            a=m\n    return (a+b)/2\n\n\nn=int(input('n?'))\nx=np.linspace(0,1,501)\nfor k in range (1,n+1):\n    y= f(k,x)\n    plt.plot(x,y)\n    plt.plot(dicho(k),0,'rx')\nplt.grid()\nplt.show()\n\n\n#exercice 3\n\n#version 1\n\ndef suiteuV1(n):\n    u,v=0,1\n    for k in range (2,n+1):\n        w=u+v  #un+2=un+1+un\n        u,v=v,w # un+1=un et un+1=un+2\n    return v\n\n#version 2\n\ndef suiteuV2(n):\n    u,v=0,1\n    for k in range (2,n+1):\n        w=u+v\n        u=v\n        v=w\n    return v\n\ndef nb_or():\n    rho=(1+sqrt(5)/2)\n    p=1\n    while abs(suiteuV1(p+1)/suiteuV1(p))-rho&gt;10**-10:\n        p=p+1\n    return p\n\n#exercice 4\n\ndef Edhec21():\n    s=0\n    u=1\n    k=0 #compteur\n    while s&lt;=1000:\n        s=s+u\n        u=sqrt(u**2+u)\n        k=k+1\n    return k\n\ndef Edhec21b():\n    u=1\n    k=0\n    while u**2-1&lt;=1000:\n        u=sqrt(u**2+u)\n        k=k+1\n    return k\n</code></pre>","path":["2ème année","TP","TP1 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille2/Feuille2/","level":1,"title":"TP2 — Exercices et correction","text":"<p>Voir les exercices (PDF) de 2025/2026</p> <p>Voir les exercices (PDF) de 2024/2025</p> <p>Télécharger la correction du prof</p> <p>Télécharger mes réponses du PDF 2024/2025</p>","path":["2ème année","TP","TP2 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille2/Feuille2/#correction-du-prof-20252026","level":3,"title":"Correction du prof 2025/2026:","text":"<pre><code>#Feuille 2\n\n#exercice 1\n\ndef f(x):\n    y=1/(1+x**2)\n    return y\nepsilone=float(input('donner un réel positif assez petit eps='))\nRn=0\nN=int(np.floor(1/2*epsilone))\nfor k in range (1,N+1):\n    Rn=Rn+1/N*f(k/N)\nprint('la valeur approchée de pi à ', epsilone, 'près est', 4*Rn)\n\n #exercice 2\n\n #a\n\ndef Lagrange(L,x,k):  #Lk(x) L=[x0,x1...xn]\n    n=len(L)\n    p=1\n    for j in range (0,n+1):\n        if j!=k:\n            p=p*(x-L[j]/(L[k]-L[j]))\n    return p\n\nLagrange([-2,-1,0,1,2],-2,0)  #L0x0\n\n#b\n\nimport matplotlib.pyplot as plt\nL=eval(input('donner les valeurs de la liste L'))\nn=len(L)\nx= np.linspace(-3,3,150)   #domaine d'étude de la fonction L-k\nfor k in range (0,n):\n    y=Lagrange(L,x,k)  #calcul des images de l'intervalle d'étude x\n    plt.plot(x,y) #représentation de x en fct de y\nplt.grid()\nplt.show()\n\n#exercice 3\n\ndef f(x):\n    y= x + np.log(x)\n    return y\ndef df(x):\n    y=1+1/x\n    return y\na= float(input('a=')) #le 1er terme de la suite an est a0= a\nepsilone= float(input('epsilone='))\nk=0\nwhile abs(f(a)/df(a))&gt;epsilone:\n    a=a-f(a)/df(a)  #calcul des termes de an\n    k=k+1  #calcul du nombre d'itéra° nécessaire pour calculer valeur approc de x0\n    print(\"la valeur approchée de l'équation g(x)=0 est x0=\", a, \"le nouveau\")\n\n\n#exercice 4\n\ndef eval_poly(P,x0):\n    z=0\n    n=len(P) #calcul de la dimension du vecteur polynôme P\n    for k in range (n-1, -1, -1):\n        z=z*x0+ P[k]  #évalue poly en x0\n    return z\n\n#exercice 6\ndef a(n) :  #cette fct est juste pour tourner la fct somme\n    return 1+0.5**n\ndef somme(n):\n    denominateur=s=0\n    for k in range (1,n+1):\n        denominateur=denominateur + a(k)\n        s+=k/denominateur\n    return s\n\n#exercice 7\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom math import *\nn=1\nS=atan(1/2)-atan(0)\nwhile 1/2*(pi/2-atan(n))&gt;=0.001:\n    S=S+atan(n+1/2)-atan(n)\n    n=n+1\nprint('n=',n,\"S=\", S)\n\n\nfor n in range (0,floor(tan(pi/2-0.002))+1):\n    S=S+atan(n+1/2)-atan(n)\nprint(\"S_méthode2= \", S)\n\n\n#exercice 8\n\ndef EML2015():\n    n=0\n    s=0\n    while exp(-n)/(-1+(e(1)))&gt;10**-4:\n        n=n+1\n        s+=1/(n**3*exp(n))\n    return s\n\n#♥ Méthode 2\nfrom math import sqrt\ndef h(e):\n    k=0\n    a=sqrt(3)/2\n    b=1/2\n    while abs((9*2**k*(a/(2+b)))-(2**k*(2*a+a/b)))&gt;2*e:\n        a=sqrt((1-b)/2)\n        b=sqrt((1+b)/2)\n        k+=1\n    x=((9*2**k*(a/(2+b)))+(2**k*(2*a+a/b)))/2\n    return x,k\n\ndef EML2015M2():\n    s=0\n    for k in range (1, 1+ floor(-log((e-1)*0.0001))):\n        s+=1/(n**3*exp(n))\n        return s\n\ndef iteration(p):\n    liste_iter=[k for k in range (0,p)]\n    for i in range (0,p):\n        x=h(10**(i-1))\n        liste_iter[i]=x[i]  #nombre d'iteration\n    return liste_iter\n\ndef iteration2(p):\n    return [h(10**(-i))[1] for i in range (1,p+1)]\n</code></pre>","path":["2ème année","TP","TP2 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille2/Feuille2/#mes-reponses-du-pdf-20242025","level":3,"title":"Mes réponses du PDF 2024/2025:","text":"<pre><code># En cours\n\n# Exercice 1:\n\n\"\"\"import numpy as np\n\ndef f(x):\n    return 1/(1+x**2)\n\neps=float(input(\"eps ? \"))\nRn=0\nN=int(np.floor(1/eps))+1 # N tel que 1/N &lt; eps\nfor k in range(1,N+1):\n    Rn=Rn+1/N*f(k/N)\nprint(4*Rn, eps)\"\"\"\n\n# Exercice 2:\nn=10 # int(input(\"n ? \"))\ndef L(k,X, x):\n    p=1\n    for j in range(len(X)):\n        p*=(x-X[j])/(X[k]-X[j]) if j!=k else 1\n    return p\nprint(L(3,[1,2,3,4,5,6,7,8,9,10,11],1.5))\n\nimport matplotlib.pyplot as plt\nimport numpy as np\nx=np.linspace(-3,3,100)\nl=[-2, -1, 0, 1, 2]\nfor k in range(len(l)):\n    y=[L(k, l, xi) for xi in x]\n    plt.plot(x,y)\nplt.grid()\nplt.show()\n\n\n# Exercice 3:\n\n\"\"\"import numpy as np\n\ndef f(x): return x+np.log(x)\n\ndef df(x): return 1+1/x\n\n\ndef newton(f, df, a, eps):\n    an=a\n    anp=an-f(an)/df(an)\n    i=1\n    while abs(anp-an)&gt;eps:\n        an=anp\n        anp=an-f(an)/df(an)\n        i+=1\n    return an, i\n\nprint(newton(f, df, 1, 10e-10))\"\"\"\n\n\n# Exercice 4: \n\"\"\"p=[1, 0, -2, 1]  # x^3 - 2x + 1\ndef eval_poly(p, x0):\n    r=p[0]\n    for i in range(1, len(p)):\n        r=r*x0+p[i]\n    return r\nprint(eval_poly(p, 2))\"\"\"\n\n\n# Exercice 5:\n\n# 1)\n\n\"\"\"from numpy import exp, sqrt\nn=0\nwhile exp(-sqrt(n))&gt;10e-4:\n    n+=1\nprint(n)\"\"\"\n\n# Exercice 6:\n\"\"\"import numpy as np\n\ndef f(x): return np.exp(x)*x**3\nn=0\nS=0\nwhile 1/((np.e-1)*np.exp(n))&gt;10e-4:\n    n+=1\n    S+=1/f(n)\nprint(n, S)\"\"\"\n\n\n# Exercice 7:\n\n\"\"\"eps=10e-2\nx=2\n\nk=1\nwhile 1/(k+1)**x&gt;eps: k+=1\n\nprint(sum([((-1)**(k+1))/k**x for k in range(1,k+1)]), k)\"\"\"\n\n\n# Exercice 8\n\n\"\"\"# 5)\nfrom math import factorial, pi\nfrom numpy import zeros\ndef I(n):\n    u=zeros(2*n+2)\n    u[0]=0\n    u[1]=1\n    for i in range(2, 2*n+2):\n        u[i]=((factorial(2*n)/(2**n*factorial(n)))**2)*(pi/2) if i%2==0 else ((factorial(n)*2**n)**2)/factorial(2*n+1)\n    y=u\n    return y\n\nprint(I(3))\n\n\n# 6)\n\ndef SI(n):\n    return sum(I(n)[:n+1])\n\nprint(SI(3))\"\"\"\n\n\n# Exercice 9\n\n# 2)\nfrom math import sqrt\ndef h(e):\n    k=0\n    a=sqrt(3)/2\n    b=1/2\n    while abs((9*2**k*(a/(2+b)))-(2**k*(2*a+a/b)))&gt;2*e:\n        a=sqrt((1-b)/2)\n        b=sqrt((1+b)/2)\n        k+=1\n    x=((9*2**k*(a/(2+b)))+(2**k*(2*a+a/b)))/2\n    return x,k\nprint(h(10e-5))\n\nimport matplotlib.pyplot as plt\ndef evol(p):\n    l=[]\n    for i in range(1,p+1):\n        l.append(h(10**-i)[1])\n    plt.scatter(range(1,p+1), l)\n    plt.show()\n\nevol(30)\n\n\n# On remarque une évolution linéaire jusqu'à 10**-16, puis une stagnation.\n# Ceci est du à la précision des floats python (base 64 donc environ 15 à 17 decimales).\n</code></pre>","path":["2ème année","TP","TP2 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille3/Feuille3/","level":1,"title":"TP3 — Exercices et correction","text":"<p>Voir les exercices (PDF)</p> <p>Télécharger la correction du prof</p>","path":["2ème année","TP","TP3 — Exercices et correction"],"tags":[]},{"location":"2eme/Feuille3/Feuille3/#correction-du-prof","level":3,"title":"Correction du prof :","text":"<pre><code>#Feuille 3\n\nfrom numpy.random import*\nimport numpy.random as rd\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n#Exercice 1\n\n\n##1)\ndef simule():\n    X=rd.random()\n    if X&lt;0.2:\n        sortie=1\n    else:\n        sortie=0\n    return sortie\n\n\ndef simule():\n    X=rd.random()\n    if X&lt;0.2:\n        sortie=1\n    else:\n        sortie =0\n    return sortie\n##2)\n\nprint('Frequence=',np.mean([simule() for k in range(10000)]))\n\nprint('Frequence=',sum([simule() for k in range(10000)])/10000)\n\ns=0\nfor k in range (10000):\n    s=s+simule()\nprint('Frequence=', s/10000)\n\n#Exercice 2\n\n#1)\ndef simuleU(n):\n    Y=0\n    while rd.random()&gt;1/(2*n-1):\n        Y=Y+1\n    return Y\n#ou\ndef simuleU2(m):\n    urne=2*[i for i in range(1,m+1)]\n    Y=0\n    while True:\n        Y+=1\n        b1,b2=random.sample(urne,2)\n        if b1==b2:\n            return Y\n#2)\n\nn=int(input('n='))\nz=0\nfor k in range(n,0,-1):\n    z=z+simuleU(k)\nprint(\"le nmbre de tirage nécessaire pour vider l'urne est\", z)\n\n#ou\nprint('La valeur Z=', sum(simuleU(i) for i in range (n, 0, -1)))\n\n\n#ex3\n\ndef simuleX():\n    Lancer=rd.random()\n    if 0&lt;Lancer&lt;=1/5:\n        x=0\n    elif 1/5&lt;Lancer&lt;=7/10:\n        x=2\n    elif 7/10&lt;Lancer&lt;=9/10:\n        x=5\n    else:\n        x=10\n    return x\n\nprint('Moyenne empirique pour =', np.mean([simuleX() for k in range (10000)]))\n\n#q3\nn=int(input('n='))\nE=0\nfor k in range(n):\n    E+=simuleX()\nprint('Moyenne empirique pour n=',n, 'est', E/n, 'à comparer avec E=3')\n\n\n#ex4\n\n#1)\n\ndef Uniforme(n,m):\n    return(int(m-n)*rd.random())+n\n#retourne le résultat d'1 réalisa° d'1 loi uniforme sur l'ensemble des entiers i\n#tels que n&lt;=i&lt;=m-1 avec n et m-1 des entiers relatifs\n\n#2)\n\ndef Uniforme2(n,m,N):\n    v=np.zeros(N)\n    for k in range(N):\n        v[k]=Uniforme(n,m)\n    return v\n\n#ex5\n\ndef Bernoulli(p):\n    u=0\n    if rd.random()&lt;=p:\n        u=1\n    return u\n\ndef Bernoulli(p):\n    lancer=rd.random()\n    if lancer&lt;p:\n        u=1\n    else:\n        u=0\n    return u\n\n\ndef BernoulliN(p,N):\n    v=np.zeros(N)\n    for k in range(N):\n        v[k]=Bernoulli(p)\n    return v\n\n\n#ex6\n\ndef binomiale(n,p):\n    s=0\n    for k in range(n):\n        s=s+Bernoulli(p)\n    return(s)\n\ndef binomiale(n,p):\n    s=0\n    for k in range (n):\n        alea=rd.random()&lt;p\n        s=s+alea\n    return(s)\n\n\ndef binomialeN(n,p,N):\n    v=np.zeros(N)\n    for k in range(N):\n        v[k]=binomiale(n,p)\n    return v\n\n#ex7\n\ndef geometrique(p):\n    x=1\n    while rd.random()&gt;p:\n        x+=1\n    return x\n\ndef GEOM(P,N):\n    L=[]\n    for k in range(N):\n        L.append(geometrique(P))\n    return L\n\nN=int(input('N='))\nP=float(input('P='))\nMOYENNE=np.mean(GEOM(P,N))\nprint(('Espérance=', MOYENNE))\n</code></pre>","path":["2ème année","TP","TP3 — Exercices et correction"],"tags":[]}]}