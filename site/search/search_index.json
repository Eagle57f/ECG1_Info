{"config":{"lang":["fr"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cours d'informatique en ECG1-2","text":""},{"location":"#site-du-cours-dinformatique-de-deuxieme-annee","title":"Site du cours d'informatique de deuxi\u00e8me ann\u00e9e :","text":""},{"location":"#depot-github-de-premiere-annee","title":"D\u00e9p\u00f4t GitHub de premi\u00e8re ann\u00e9e :","text":""},{"location":"#sommaire","title":"Sommaire","text":"<ul> <li>Cours 1 - Bases du Python</li> <li>Cours 2 - Boucles for et while, tests</li> <li>Cours 3 - Listes</li> <li>Cours 4 - Fonctions</li> <li>Cours 5 - Matrices avec Numpy</li> <li>Cours 6 - Graphiques avec Matplotlib</li> </ul>"},{"location":"#exercicesressourcescorrections","title":"Exercices/Ressources/Corrections","text":"<ul> <li>Exercices</li> <li>Corrections de DS<ul> <li>Correction du DS Final 2024</li> <li>Correction du DS Final 2025</li> </ul> </li> <li>Ressources<ul> <li>Toutes les fonctions de 1\u00e8re ann\u00e9e</li> </ul> </li> </ul>"},{"location":"#quelques-ressources-pour-approfondir","title":"Quelques ressources pour approfondir","text":"<ul> <li> <p>Vid\u00e9os (ou playlists):</p> <ul> <li>Graven (FR): https://www.youtube.com/watch?v=psaDHhZ0cPs&amp;list=PLMS9Cy4Enq5JmIZtKE5OHJCI3jZfpASbR</li> <li>Docstring (FR): https://www.youtube.com/watch?v=LamjAFnybo0&amp;list=PLXDBYzqsqO3Wut-gQktoqJ30eaOel0hgb</li> <li>FormationVid\u00e9o (FR): https://www.youtube.com/watch?v=HWxBtxPBCAc&amp;list=PLrSOXFDHBtfHg8fWBd7sKPxEmahwyVBkC</li> <li>NetworkChuck (EN): https://www.youtube.com/watch?v=mRMmlo_Uqcs</li> <li>freeCodeCamp.org (EN): https://www.youtube.com/watch?v=LHBE6Q9XlzI</li> </ul> </li> <li> <p>Sites web:</p> <ul> <li>Python Doctor (FR): https://python.doctor/</li> <li>w3schools (EN): https://www.w3schools.com/</li> </ul> </li> </ul>"},{"location":"Correction_DS_2024/","title":"Correction DS 2024","text":"<pre><code># Des erreurs peuvent \u00eates pr\u00e9sentes dans ce fichier, si vous en trouvez, merci de me le signaler.\n# J'ai surtout r\u00e9pondu aux questions python, pas \u00e0 celles de maths.\n\n# Sujet : DS Final 2024\n\n# I Exercices sur les suites\n\n# 1.1 Suites r\u00e9currentes\n\n# 1.\n\nn=int(input(\"Donnez n: \"))\ndef u1(n):\n    if n==0:\n        return 2\n    return 3*(u1(n-1))**2 - 1\nprint(u1(n))\n\n\n# 2.\n\nimport math\n\nn=int(input(\"Donnez n: \"))\ndef u2(n):\n    if n==1:\n        return 0\n    return math.exp(-u2(n-1))\nprint(u2(n))\n\n\n# 3.\n\nn=int(input(\"Donnez n: \"))\ndef u3(n):\n    if n==0 or n==1:\n        return 1\n    return u3(n-1) + u3(n-2)\nprint(u3(n))\n\n\n# 4. Version avec la somme\n\nn=int(input(\"Donnez n: \"))\ndef u4(n):\n    if n==0:\n        return 1\n    s=0\n    for i in range(n):\n        s=s+(u4(i)/(i**2+1))\n    return s\nprint(u4(n))\n\n\n# 4. Version sans la somme\n\nn=int(input(\"Donnez n: \"))\ndef u4bis(n):\n    if n==0:\n        return 1\n    return u4bis(n-1)*((n-1)**2+2)/((n-1)**2+1)\nprint(u4bis(n))\n\n\n# 1.2 Suites imbriqu\u00e9es\n\n# 2.\n\nn=int(input(\"Donnez n: \"))\ndef suites(n):\n    def a(n):\n        if n==0:\n            return 0\n        return 2*a(n-1) + b(n-1)\n\n    def b(n):\n        if n==0:\n            return 1\n        return 2*a(n-1) + 3*b(n-1)\n\n\n    return a(n), b(n)\n\nprint(suites(n))\n\n\n# 1.3 Suites d\u00e9finies par une somme ou un produit\n\n# 1.\n\nn=int(input(\"Donnez n: \"))\ns=0\nfor i in range(1,n+1):\n    s=s+1/i**2\nprint(s)\n\n\n# 2.b\n\nn=int(input(\"Donnez n: \"))\np=1\nfor i in range(2,n+1):\n    p=p*(1-1/i**2)\nprint(p)\n\n\n# 2.f\n\na=eval(input(\"Donnez a: \"))\ndef seuil(a):\n    n=2\n    v=3/4\n    while v-1/2&gt;a:\n        v=(n+1)/2**n\n        n=n+1\n    return n\nprint(seuil(a))\n\n\n# 3.c\n\nn=int(input(\"Donnez n: \"))\n\ndef a(n):\n    s=0\n    for i in range(1,n+1):\n        s=s+i\n    return s**4\n\ndef b(n):\n    s=0\n    for i in range(1,n+1):\n        s=s+i**4\n    return s\n\ndef difference(n):\n    return a(n) - b(n)\n\nprint(difference(n))\n\n\n\n# II Simulation et fr\u00e9quences\n\n# II.1 Simulation 1\n\n# 1.\n\nfrom random import *\nx=random()\nif x&lt;1/3:\n    piece=\"PILE\"\nelse:\n    piece=\"FACE\"\nprint(piece)\n\n\n# 2.\n\ndef simulX():\n    i=0\n    for k in range(3):\n        x=random()\n        if x&lt;1/3:\n            i+=1\n    return i\nprint(simulX())\n\n\n# II.2 Simulation 2\n\n# 1.\n\ndef simul2X():\n    for i in range(1, 5):\n        if random() &lt; 1/3:\n            return i\n    return 4\nprint(simul2X())\n\n\n# 2. Version simple\n\nn=int(input(\"Donnez n: \"))\ndef simultipleX(n):\n    s=0\n    for i in range(n):\n        s=s+simul2X()\n    return s/n\nprint(simultipleX(n))\n\n\n# 2. Version avanc\u00e9e\n\nn=int(input(\"Donnez n: \"))\ndef simultipleXbis(n):\n    return sum([simul2X() for _ in range(n)])/n\nprint(simultipleXbis(n))\n\n\n\n# III Matrices\n\n# 1.\n\nimport numpy as np\n\n\n# 2.\n\nimport numpy as np\nA=np.array([[1,2,3], [2,-7,6]])\n\n\n# 3.\n\nimport numpy as np\nB=np.array([[1,2], [3,4], [5,6]]) # Ligne non demand\u00e9e, pour \u00e9viter les erreurs dans ce fichier, ne pas la mettre dans le DS\nnp.dot(A,B)\n\n\n# 4.\n\nimport numpy as np\nnp.eye(n)\n\n\n# 5.\n\nprint(np.size(A)) # Renvoie 6\n\n\n# 6.\n\nprint(A[1,2]) # Renvoie 6, car on commence \u00e0 compter les lignes et colonnes \u00e0 partir de 0, et non de 1.\n\n\n\n# IV Op\u00e9rations sur les listes\n\n# 1.\n\n# R\u00e9ponse : 1\n\n\n# 2.\ncorr0 = [4, 2, 1, 4, 3, 1, 3, 3, 2, 1, 1, 3, 3, 2, 4, 4, 2, 1, 3, 3]\nprint(corr0[17]) # Renvoie 1, car le premier item de la liste \u00e0 l'indice 0\n\n\n# 3.\n\n# R\u00e9ponse : False\n\n\n# 4.\n\ncopTM = [4, 1, 2, 4, 3, 3, 1, 4, 3, 3, 2, 1, 3, 2, 4, 1, 3, 3, 2, 3]\n\ncorrTM = [True, False, False, True, True, False, False, False, False, False, False, False, True, True, True, False, False, False, False, True]\n\n# Approfondissement : Algorithme pour g\u00e9n\u00e9rer cette liste automatiquement :\ncorrTM = [copTM[i]==corr0[i] for i in range(len(copTM))]\nprint(corrTM)\n\n\n# 5.\n\ndef note(cop,corr):\n    n=0\n    for i in range(len(cop)):\n        if corr[i]==cop[i]:\n            n+=1\n    return n\n\nprint(note(copTM, corr0))\n\n\n# 6. Version simple\n\ndef reussite(cop,corr):\n    if note(cop,corr) &gt;= 10:\n        return \"R\u00e9ussite\"\n    else:\n        return \"Echec\"\nprint(reussite(copTM, corr0))\n\n\n# 6. Version en une ligne\n\ndef reussite(cop,corr):\n    return \"R\u00e9ussite\" if note(cop,corr)&gt;=10 else \"Echec\"\nprint(reussite(copTM, corr0))\n\n\n# 7.\n\ndef notebonus(cop,corr):\n    n=0\n    for i in range(len(cop)):\n        if corr[i]==cop[i]:\n            n+=1 # Pareil que d'\u00e9crire n=n+1\n            if n==4:\n                if note(cop,corr) + 2 &lt;= 20:\n                    return note(cop,corr) + 2\n                else:\n                    return 20\n        else:\n            n=0\n    return note(cop,corr)\n\nprint(notebonus(copTM, corr0))\n\n\n\n# V Courbes repr\u00e9sentatives de fonctions\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nx = np.linspace(-1, 2, 200)\ny = np.exp(x**2)\n\nplt.plot(x, y, label='f(x) = e^{x\u00b2}')\nplt.title('Courbe repr\u00e9sentative de f(x) = e^{x\u00b2}')\nplt.legend()\nplt.show()\n</code></pre>"},{"location":"Correction_DS_2025/","title":"Correction DS 2025","text":"<pre><code># Des erreurs peuvent \u00eates pr\u00e9sentes dans ce fichier, si vous en trouvez, merci de me le signaler.\n# J'ai surtout r\u00e9pondu aux questions python, pas \u00e0 celles de maths.\n\n# Sujet : DS Final 2025\n\n# Exercice 1\n\n# 1)\n\nimport numpy as np\n\ndef Liste(n):\n    L=[]\n    for i in np.linspace(1,20,n):\n        L.append(int(i))\n    return L\nprint(Liste(30))\n\n# 2)\n\ndef Som(L):\n    s=0\n    for i in L:\n        if i%2==0:\n            s+=i\n    return s\nprint(Som([1,2,3,4,5,6,7,2,3,9,34,63]))\n\n# 3)\nL=[114, 15, 20, 152, 45, 87, 26, 153, 0, -7, 147, 158, 1258]\nprint(Som(L))\n\n# Exercice 2\n\ndef FACTO(n):\n    if n==0 or n==1:\n        return 1\n    return FACTO(n-1)*n\n\n# Exercice 3\n\n# 1)\n\nfrom math import sqrt\n\ndef suite(n):\n    if n==0:\n        return 0.5\n    elif n==1:\n        return 1\n    return sqrt(suite(n-1))+sqrt(suite(n-2))\nprint(suite(5))\n\n\n# Exercice 4\n\ndef pal(L):\n    Lbis=L.copy()\n    Lbis.reverse()\n    return L==Lbis\n\nprint(pal([1,2,3,2,1]))\nprint(pal([1,2,3,4]))\n\n# OU\n\ndef pal(L):\n    return L==L[::-1]\n\nprint(pal([1,2,3,2,1]))\nprint(pal([1,2,3,4]))\n\n\n# Exercice 5\n\n# 1)\n\ndef SIMPLE(L):\n    Lbis=[]\n    for i in L:\n        if i not in Lbis:\n            Lbis.append(i)\n    return Lbis\nprint(SIMPLE([1,3,4,2,1,4,6,2,9,0,1]))\n\n\n# 2)\n\ndef PREMS(L, elem):\n    if elem in L:\n        return L.index(elem)\n    else:\n        return -1\nprint(PREMS([1,2,4,5,2], 2))\nprint(PREMS([1,2,4,5,2], 6))\n\n\n# Exercice 6\n\nLISTE=[1,4,5,2,6,3,6,6,5] # Exemple\n\ndef f(LISTE):\n    m=max(LISTE)\n    for _ in range(LISTE.count(m)):\n        LISTE.remove(m)\n    return max(LISTE)\nprint(f(LISTE))\n\n\n# Exercice 7\n\n# Partie A\n\n# 1)\n\nimport matplotlib.pyplot as plt\n\n\n# 2)\n\nplt.show()\n\n\n# Partie B\n\nmois = [\"Jan\", \"Fev\", \"Mar\", \"Avr\", \"Mai\", \"Juin\"]\ntemperatures = [5, 7, 12, 15, 20, 24]\nprecipitation = [120, 90, 80, 65, 50, 30]\n\nimport matplotlib.pyplot as plt\n\nplt.plot(mois, temperatures)\nplt.title(\"Evolution des temp\u00e9ratures\")\nplt.xlabel(\"Mois\")\nplt.ylabel(\"Temp\u00e9ratures\")\nplt.grid()\nplt.show()\n\n\n# Partie C\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef f(x): return (x-2)/(x+3)\n\nx=np.linspace(-2, 5, 100)\ny=f(x)\nplt.plot(x,y)\nplt.show()\n\n\n# Exercice 8\n\n# 1)\n\n# Renvoie [34, -91, 5, 67]\n\n\n# 2)\n\n# Renvoie [-91, 5, 67, -89, 23, 56.12, 3, 73, 82, -19, 50, 6, -11]\n\n\n# 3)\n\n# Renvoie [45, 12, 78.5, 34, -91, 5, 67, -89, -5, 23, 56.12, 3, 73, 82, -19, 50, 6, -11]\n\n\n# 4)\n\n# Renvoie une erreur, car -1 n'est pas dans la liste. Si on ignore l'erreur (Hors Programme),\n# on obtient la m\u00eame liste que la question pr\u00e9c\u00e9dente.\n\n\n# 5)\n\n# Renvoie [-91, 23, -19]\n\n\n# Exercice 9\n\nimport matplotlib.pyplot as plt\nabscisses = [1, 2.5, 2, 2, 0, 0, -0.5, 1]\nordonnees =[3, 2, 2, 0, 0, 2, 2, 3]\nplt.plot(abscisses, ordonnees)\nplt.grid()\nplt.show()\n\n\n# Exercice 10\n\nfrom math import *\ndef suite(n):\n    if n%2==0:\n        u=log(3)/4\n        for k in range(2, n+1, 2):\n            u = 4*u - 00000000 # Je n'ai pas la formule obtenue \u00e0 la question pr\u00e9c\u00e9dente\n    else:\n        u=log(2/sqrt(3))\n        for k in range(3, n+1, 2):\n            u = 4*u - 00000000 # Je n'ai pas la formule obtenue \u00e0 la question pr\u00e9c\u00e9dente\n    return u\nprint(suite(10))\n</code></pre>"},{"location":"Exercice_Methode_de_Monte_Carlo/","title":"Correction : Exercice M\u00e9thode de Monte-Carlo","text":"<pre><code># Exercice : M\u00e9thode de Monte-Carlo pour calculer l'aire sous la courbe de exp(x) entre a et b\n\n\n# Explication de la m\u00e9thode de Monte-Carlo :\n# 1. On choisit un intervalle [a, b] et on g\u00e9n\u00e8re n_points points al\u00e9atoires dans un rectangle\n#    de largeur b-a et de hauteur max(exp(t)) pour t allant de a \u00e0 b.\n# 2. On compte combien de ces points sont sous la courbe de exp(x).\n# 3. L'aire sous la courbe est approxim\u00e9e par le ratio du nombre de points sous la courbe sur\n#    le nombre total de points, multipli\u00e9 par l'aire du rectangle.\n\n# Consigne :\n# La fonction monte_carlo_exp prend en entr\u00e9e les bornes a et b de l'intervalle ainsi que le\n# nombre de points n_points \u00e0 g\u00e9n\u00e9rer. Elle renvoie l'aire sous la courbe entre a et b, et\n# affiche un graphique avec la courbe de exp entre a et b, ainsi qu'un nuage de points, avec\n# les points sous la courbe en vert et ceux au-dessus en rouge.\n# Compl\u00e9tez la fonction monte_carlo_exp.\n\n\n\n# Correction possible:\n\n\nimport random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points):\n    y_max = max([math.exp(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(n_points):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= math.exp(x):\n            count_under_curve += 1\n            xs_in.append(x)\n            ys_in.append(y)\n        else:\n            xs_out.append(x)\n            ys_out.append(y)\n\n    area_rectangle = (b - a) * y_max\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [math.exp(x) for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='exp(x)')\n    plt.scatter(xs_in, ys_in, color='green', s=1, label='Sous la courbe')\n    plt.scatter(xs_out, ys_out, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt.title(f\"Monte Carlo pour aire sous exp(x) entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.show()\n\n    return area_under_curve\n\n\na = 0\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points)\nprint(f\"Aire approximative sous exp(x) entre {a} et {b} : {aire}\")\n\n# Correction question BONUS\n\n\nimport random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points, f):\n    y_max = max([f(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(n_points):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= f(x):\n            count_under_curve += 1\n            xs_in.append(x)\n            ys_in.append(y)\n        else:\n            xs_out.append(x)\n            ys_out.append(y)\n\n    area_rectangle = (b - a) * y_max\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [f(x) for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='f(x)')\n    plt.scatter(xs_in, ys_in, color='green', s=1, label='Sous la courbe')\n    plt.scatter(xs_out, ys_out, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt.title(f\"Monte Carlo entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt.xlabel(\"x\")\n    plt.ylabel(\"y\")\n    plt.show()\n\n    return area_under_curve\n\n\na = 1\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points, math.log) # Autre fonction, comme exemple\nprint(f\"Aire approximative entre {a} et {b} : {aire}\")\n</code></pre>"},{"location":"Exercice_Probabilites_1/","title":"Correction : Exercice Probabilit\u00e9s 1","text":"<pre><code># Exercice 1: Simulation d'une variable al\u00e9atoire, sans remise\n\n\n#   On tire al\u00e9atoirement trois cartes d'un jeu de n cartes (sans remise), n&gt;4, les cartes sont\n#   num\u00e9rot\u00e9es de 0 \u00e0 n-1.\n#   X est la variable al\u00e9atoire qui repr\u00e9sente la somme des valeurs des cartes tir\u00e9es.\n#\n# 1) Simulez par une fonction X(n) X pour 20 cartes, et renvoyez la valeur de X.\n#\n# 2) a. Simulez par une fonction Xk(n, k) k tirages, et renvoyez la moyenne de X sur ces k tirages.\n#    b. Renvoyez \u00e9galement par la fonction Xk(n, k) le pourcentage de fois o\u00f9 X est sup\u00e9rieur \u00e0 2*n.\n#\n# 3) a. Affichez un graphique de la moyenne de X en fonction de n, pour n variant de 5 \u00e0 200,\n#       et k=1000.\n#    b. Affichez sur ce m\u00eame graphique le pourcentage de fois o\u00f9 X est sup\u00e9rieur \u00e0 2*n en fonction\n#       de n, pour n variant de 5 \u00e0 200, et k=1000.\n#    c. Affichez la droite d'\u00e9quation y=1.5x en pointill\u00e9s rouges sur le graphique pr\u00e9c\u00e9dent,\n#       la droite doit \u00eatre derri\u00e8re les autres courbes sur le graphique (il faut donc mettre\n#       la ligne de code pour cr\u00e9er la droite avant celles pour cr\u00e9er les courbes).\n#    d. Ajoutez un titre, des labels aux axes, une grille et une l\u00e9gende.\n\n\n# Correction possible de l'exercice 1:\n\n# 1)\n\nimport random\n\ndef X(n):\n    L=[i for i in range(0, n+1)]\n    s=0\n    for i in range(3):\n        x=random.randint(0, len(L)-1)\n        a=L.pop(x)\n        s+=a\n    return s  \nprint(X(7))\n\n\n# 2)\n\ndef Xk(n, k):\n    total = 0\n    sup=0\n    for i in range(k):\n        x=X(n)\n        total += x\n        if x &gt; 2*n:\n            sup+=1\n    return total/k, sup/k*100\n\nprint(Xk(20, 1000))\n\n# 3)\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nn_values = np.linspace(5, 200, 196) # 196 car il y a 196 valeurs entre 5 et 200 (les deux extr\u00eames inclus)\nplt.plot(n_values, 1.5*n_values, '--', color='red', label=\"y = 1.5x\") # Ligne rouge en pointill\u00e9s pour x=y\ny_values = [Xk(int(n), 1000)[0] for n in n_values] # On utilise [0] pour obtenir le premier \u00e9l\u00e9ment des deux retourn\u00e9s par Xk (Donc la moyenne de X)\nplt.plot(n_values, y_values, label=\"Moyenne de X pour n cartes\")\ny2_values = [Xk(int(n), 1000)[1] for n in n_values] # On utilise [1] pour obtenir le second \u00e9l\u00e9ment des deux retourn\u00e9s par Xk (Donc le pourcentage de fois o\u00f9 X est sup\u00e9rieur \u00e0 2*n)\nplt.plot(n_values, y2_values, label=\"Pourcentage de X &gt; 2*n\")\nplt.xlabel(\"Nombre de cartes\")\nplt.ylabel(\"Moyenne de X et\\npourcentage de X &gt; 2*n\")\nplt.title(\"Moyenne de X en fonction de n et pourcentage de fois o\u00f9 X &gt; 2*n,\\npour k=1000\")\nplt.grid()\nplt.legend()\nplt.show()\n\n# Pour tirer al\u00e9atoirement k \u00e9l\u00e9ments distincts d'une liste de n \u00e9l\u00e9ments (k&lt;=n), on peut\n# utiliser la fonction sample(liste, k) de la biblioth\u00e8que random, elle n'est pas\n# obligatoire mais peut \u00eatre utile.\n</code></pre>"},{"location":"Exercice_Probabilites_2/","title":"Correction : Exercice Probabilit\u00e9s 2","text":"<pre><code># Exercice 2: Cha\u00eene de Markov\n\n\n#   On consid\u00e8re un syst\u00e8me avec 3 \u00e9tats num\u00e9rot\u00e9s 0, 1, et 2. Le syst\u00e8me \u00e9volue de mani\u00e8re\n#   probabiliste selon les transitions suivantes:\n#   - Au temps t=0, le syst\u00e8me est dans l'\u00e9tat 0 avec une probabilit\u00e9 de 1.\n#   - Si l'\u00e9tat actuel est 0, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.3, \u00e0 1 avec une\n#     probabilit\u00e9 de 0.4, et \u00e0 2 avec une probabilit\u00e9 de 0.3.\n#   - Si l'\u00e9tat actuel est 1, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.2, \u00e0 1 avec une\n#     probabilit\u00e9 de 0.5, et \u00e0 2 avec une probabilit\u00e9 de 0.3.\n#   - Si l'\u00e9tat actuel est 2, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.6, \u00e0 1 avec une\n#     probabilit\u00e9 de 0.3, et \u00e0 2 avec une probabilit\u00e9 de 0.1.\n#   La variable al\u00e9atoire X repr\u00e9sente l'\u00e9tat du syst\u00e8me \u00e0 chaque instant t.\n#\n# 1) Cr\u00e9ez une fonction transition_etat(etat) qui prend l'\u00e9tat actuel en entr\u00e9e et renvoie le\n#    nouvel \u00e9tat apr\u00e8s une transition al\u00e9atoire en fonction des probabilit\u00e9s donn\u00e9es, affichez\n#    le nouvel \u00e9tat avec comme \u00e9tat actuel l'\u00e9tat 1.\n#\n# 2) Cr\u00e9ez une fonction simulation_markov(k) qui simule k transitions successives et renvoie la\n#    suite d'\u00e9tats travers\u00e9s gr\u00e2ce \u00e0 une liste, affichez cette liste pour k=20.\n#\n# 3) Cr\u00e9ez une fonction pourcentages_etats(etats) qui prend en entr\u00e9e la liste des \u00e9tats et\n#    renvoie le pourcentage de fois o\u00f9 le syst\u00e8me est dans l'\u00e9tat 0, 1 ou 2 apr\u00e8s k transitions.\n#    Affichez ces pourcentages pour k=20.\n\n\n\n# Correction possible de l'exercice 2:\n\n# 1)\n\nimport random\n\ndef transition_etat(etat):\n    if etat == 0:\n        prob_0 = 0.3\n        prob_1 = 0.4\n        prob_2 = 0.3 # Les valeurs prob_2 ne sont jamais utilis\u00e9es pour le random, car on passe \u00e0 l'\u00e9tat 2 si on ne passe ni \u00e0 l'\u00e9tat 0 ni \u00e0 l'\u00e9tat 1 (prob_2=1-prob_0-prob_1). On peut supprimer ces lignes.\n    elif etat == 1:\n        prob_0 = 0.2\n        prob_1 = 0.5\n        prob_2 = 0.3 # Pareil ici\n    else:\n        prob_0 = 0.6\n        prob_1 = 0.3\n        prob_2 = 0.1 # Pareil ici\n\n    tirage = random.random()\n    if tirage &lt; prob_0:\n        return 0\n    elif tirage &lt; prob_0 + prob_1:\n        return 1\n    else:\n        return 2\n\nprint(transition_etat(1)) \n\n\n# 2)\n\ndef simulation_markov(k):\n    etat_courant = 0 # Cas initial\n    etats = [etat_courant]\n    for i in range(k):\n        etat_courant = transition_etat(etat_courant) # On remplace l'\u00e9tat courant par le nouvel \u00e9tat apr\u00e8s la transition\n        etats.append(etat_courant)\n    return etats\n\nprint(simulation_markov(20))\n\n\n# 3)\n\ndef pourcentages_etats(etats):\n    comptage_0 = etats.count(0)\n    comptage_1 = etats.count(1)\n    comptage_2 = etats.count(2)\n\n    pourcentage_0 = (comptage_0 / len(etats)) * 100\n    pourcentage_1 = (comptage_1 / len(etats)) * 100\n    pourcentage_2 = (comptage_2 / len(etats)) * 100\n\n    return pourcentage_0, pourcentage_1, pourcentage_2\n\nprint(pourcentages_etats(simulation_markov(20)))\n</code></pre>"},{"location":"Exercices/","title":"Exercices","text":""},{"location":"Exercices/#sommaire","title":"Sommaire","text":"<ul> <li>Exercices Probabilit\u00e9s<ul> <li>Exercice 1: Simulation d'une variable al\u00e9atoire, sans remise</li> <li>Exercice 2: Cha\u00eene de Markov</li> </ul> </li> <li>Exercice M\u00e9thode de Monte-Carlo</li> </ul>"},{"location":"Exercices/#exercices-probabilites","title":"Exercices Probabilit\u00e9s","text":""},{"location":"Exercices/#exercice-1-simulation-dune-variable-aleatoire-sans-remise","title":"Exercice 1: Simulation d'une variable al\u00e9atoire, sans remise","text":""},{"location":"Exercices/#correction","title":"Correction","text":"<p>On tire al\u00e9atoirement trois cartes d'un jeu de n cartes (sans remise), n&gt;4, les cartes sont num\u00e9rot\u00e9es de 0 \u00e0 n-1. X est la variable al\u00e9atoire qui repr\u00e9sente la somme des valeurs des cartes tir\u00e9es.</p> <p>1) Simulez par une fonction X(n) X pour 20 cartes, et renvoyez la valeur de X.</p> <p>2) a. Simulez par une fonction Xk(n, k) k tirages, et renvoyez la moyenne de X sur ces k tirages.</p> <p>b. Renvoyez \u00e9galement par la fonction Xk(n, k) le pourcentage de fois o\u00f9 X est sup\u00e9rieur \u00e0 2*n.</p> <p>3) a. Affichez un graphique de la moyenne de X en fonction de n, pour n variant de 5 \u00e0 200, et k=1000.</p> <p>b. Affichez sur ce m\u00eame graphique le pourcentage de fois o\u00f9 X est sup\u00e9rieur \u00e0 2*n en fonction de n, pour n variant de 5 \u00e0 200, et k=1000.</p> <p>c. Affichez la droite d'\u00e9quation y=1.5x en pointill\u00e9s rouges sur le graphique pr\u00e9c\u00e9dent, la droite doit \u00eatre derri\u00e8re les autres courbes sur le graphique (il faut donc mettre la ligne de code pour cr\u00e9er la droite avant celles pour cr\u00e9er les courbes).</p> <p>d. Ajoutez un titre, des labels aux axes, une grille et une l\u00e9gende.</p>"},{"location":"Exercices/#exercice-2-chaine-de-markov","title":"Exercice 2: Cha\u00eene de Markov","text":""},{"location":"Exercices/#correction_1","title":"Correction","text":"<p>On consid\u00e8re un syst\u00e8me avec 3 \u00e9tats num\u00e9rot\u00e9s 0, 1, et 2. Le syst\u00e8me \u00e9volue de mani\u00e8re probabiliste selon les transitions suivantes:   - Au temps t=0, le syst\u00e8me est dans l'\u00e9tat 0 avec une probabilit\u00e9 de 1.   - Si l'\u00e9tat actuel est 0, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.3, \u00e0 1 avec une probabilit\u00e9 de 0.4, et \u00e0 2 avec une probabilit\u00e9 de 0.3.   - Si l'\u00e9tat actuel est 1, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.2, \u00e0 1 avec une probabilit\u00e9 de 0.5, et \u00e0 2 avec une probabilit\u00e9 de 0.3.   - Si l'\u00e9tat actuel est 2, il peut passer \u00e0 0 avec une probabilit\u00e9 de 0.6, \u00e0 1 avec une probabilit\u00e9 de 0.3, et \u00e0 2 avec une probabilit\u00e9 de 0.1.</p> <p>La variable al\u00e9atoire X repr\u00e9sente l'\u00e9tat du syst\u00e8me \u00e0 chaque instant t.</p> <p>1) Cr\u00e9ez une fonction transition_etat(etat) qui prend l'\u00e9tat actuel en entr\u00e9e et renvoie le nouvel \u00e9tat apr\u00e8s une transition al\u00e9atoire en fonction des probabilit\u00e9s donn\u00e9es, affichez le nouvel \u00e9tat avec comme \u00e9tat actuel l'\u00e9tat 1.</p> <p>2) Cr\u00e9ez une fonction simulation_markov(k) qui simule k transitions successives et renvoie la suite d'\u00e9tats travers\u00e9s gr\u00e2ce \u00e0 une liste, affichez cette liste pour k=20.</p> <p>3) Cr\u00e9ez une fonction pourcentages_etats(etats) qui prend en entr\u00e9e la liste des \u00e9tats et renvoie le pourcentage de fois o\u00f9 le syst\u00e8me est dans l'\u00e9tat 0, 1 ou 2 apr\u00e8s k transitions. Affichez ces pourcentages pour k=20.</p>"},{"location":"Exercices/#methode-de-monte-carlo","title":"M\u00e9thode de Monte-Carlo","text":""},{"location":"Exercices/#correction_2","title":"Correction","text":"<p>M\u00e9thode de Monte-Carlo pour calculer l'aire sous la courbe de <code>exp(x)</code> entre a et b.</p> <p>Explication de la m\u00e9thode de Monte-Carlo pour la fonction <code>exp</code>: 1. On choisit un intervalle [a, b] et on g\u00e9n\u00e8re n_points points al\u00e9atoires dans un rectangle de largeur b-a et de hauteur <code>max(exp(t))</code> pour t allant de a \u00e0 b. 2. On compte combien de ces points sont sous la courbe de <code>exp(x)</code>. 3. L'aire sous la courbe est approxim\u00e9e par le ratio du nombre de points sous la courbe sur le nombre total de points, multipli\u00e9 par l'aire du rectangle.</p> <p>Consigne :</p> <p>La fonction <code>monte_carlo_exp</code> prend en entr\u00e9e les bornes a et b de l'intervalle ainsi que le nombre de points n_points \u00e0 g\u00e9n\u00e9rer. Elle renvoie l'aire sous la courbe de la fonction exp entre a et b, et affiche un graphique avec la courbe de exp entre a et b, ainsi qu'un nuage de points, avec les points sous la courbe en vert et ceux au-dessus en rouge.</p> <p>Compl\u00e9tez la fonction <code>monte_carlo_exp</code>.</p> <p>BONUS: Transformez la fonction <code>monte_carlo_exp</code> pour qu'elle fonctionne pour n'importe quelle fonction math\u00e9matique.</p> <pre><code>import random as rd\nimport math\nimport matplotlib.pyplot as plt\n\ndef monte_carlo_exp(a, b, n_points):\n    y_max = max([_____(a + (b - a) * i / 1000) for i in range(1001)])\n    count_under_curve = 0\n\n    xs_in, ys_in = [], []\n    xs_out, ys_out = [], []\n\n    for i in range(_____):\n        x = rd.uniform(a, b)\n        y = rd.uniform(0, y_max)\n        if y &lt;= math.exp(x):\n            count_under_curve = count_under_curve + _____\n            xs_in._____(x)\n            ys_in._____(y)\n        else:\n            xs_out._____(x)\n            ys_out._____(y)\n\n    area_rectangle = _____\n    area_under_curve = (count_under_curve / n_points) * area_rectangle\n\n    x_curve = [a + (b - a) * i / 1000 for i in range(1001)]\n    y_curve = [_____ for x in x_curve]\n    plt.plot(x_curve, y_curve, color='black', label='exp(x)')\n    plt._____(_____, _____, color='green', s=1, label='Sous la courbe')\n    plt._____(_____, _____, color='red', s=1, label='Au-dessus')\n    plt.xlim(a, b)\n    plt.ylim(0, y_max)\n    plt.legend()\n    plt._____(f\"Monte Carlo pour aire sous exp(x) entre {a} et {b}: {round(area_under_curve, 3)}\")\n    plt._____(\"x\")\n    plt._____(\"y\")\n    plt._____()\n\n    return _____\n\n\na = 0\nb = 7\nn_points = 1000\naire = monte_carlo_exp(a, b, n_points)\nprint(f\"Aire approximative sous exp(x) entre {a} et {b} : {aire}\")\n</code></pre>"},{"location":"TP1/","title":"TP 1 - Introduction \u00e0 l'algorithmique, pr\u00e9sentation de python et exemples","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p>"},{"location":"TP1/#quelques-symboles","title":"Quelques symboles","text":"Symbole Signification + Addition <code>1+2==3</code> - Soustraction <code>1-2==-1</code> * Multiplication <code>2*3==6</code> ** Puissance <code>2**3==8</code> / Division <code>6/2==3</code> // Quotient division euclidienne <code>7//2==3</code> % Reste division euclidienne <code>7%2==1</code> <p>Les chiffres \u00e0 virgule s'\u00e9crivent avec un point en python. Ex: <code>1.005</code></p>"},{"location":"TP1/#variables-et-affichage","title":"Variables et affichage","text":"<p>Un algorithme python s'ex\u00e9cute dans l'ordre(1\u00e8re ligne-&gt;derni\u00e8re ligne), il faut donc initialiser les variables avant de les utiliser.</p> <pre><code>a=\"t\"\nb,c=2,3 # b==2 et c==3\nprint(a,c,b) # print permet d'afficher des valeurs dans le terminal\n</code></pre> <p>Python est sensible \u00e0 la casse, donc <code>Variable != variable</code>.</p>"},{"location":"TP1/#le-point-virgule","title":"Le point-virgule","text":"<p>En python, le point-virgule <code>;</code> n'est pas obligatoire \u00e0 la fin d'une ligne. Il est possible de l'utiliser pour s\u00e9parer plusieurs instructions sur une m\u00eame ligne, mais ce n'est vraiment pas recommand\u00e9 (PEP-0008: \"Compound statements (multiple statements on the same line) are generally discouraged\").</p> <pre><code>a=1; b=2; print(a+b) # Affiche 3\n</code></pre> <p>Dans certains cas, l'utilisation du point-virgule peut m\u00eame donner des erreurs, comme pour les instructions <code>if</code>, <code>for</code>, <code>while</code> et <code>def</code>.</p> <pre><code>print('Hi') ; for i in range (4): print ('Hello')\n# Affiche: SyntaxError: invalid syntax\n</code></pre> <p>Il est donc pr\u00e9f\u00e9rable de ne pas l'utiliser.</p>"},{"location":"TP1/#premieres-fonctions","title":"Premi\u00e8res fonctions","text":"abs(x) int(x) max(a,b,c,...) min(a,b,c,...) round(x, n) Valeur absolue <code>abs(-3)==3</code> Supprime la partie fractionnaire <code>int(-3.7)==-3</code> Maximum <code>max(2.5,-3,6)==6</code> Minimum <code>min(2.5,-3,6)==-3</code> Arrondi \u00e0 10^(-n) pr\u00e8s <code>round(3.577,1)==3.6</code>"},{"location":"TP1/#importer-une-bibliotheque","title":"Importer une biblioth\u00e8que","text":"<p>Une biblioth\u00e8que est un ensemble de fonctions et variables pr\u00e9d\u00e9finies. Il faut toujours importer la biblioth\u00e8que avant d'utiliser une fonction ou variable de cette biblioth\u00e8que. Le plus souvent, il est pr\u00e9f\u00e9rable d'importer les biblioth\u00e8ques au d\u00e9but du fichier, afin quelles soient disponibles dans tout le fichier.</p> <p>Pour importer une biblioth\u00e8que, par exemple la biblioth\u00e8que math: <pre><code>import math\nprint(math.pi) # Affiche la valeur de pi\n</code></pre> Pour importer une fonction ou variable d'une biblioth\u00e8que: <pre><code>from math import pi\nprint(pi) # Affiche la valeur de pi\n</code></pre> Pour importer toutes les fonctions et variables d'une biblioth\u00e8que: <pre><code>from math import *\nprint(pi)\n</code></pre> Il est possible de renommer une biblioth\u00e8que (on appelle ce nouveau nom un alias), on l'utilisera surtout pour les biblioth\u00e8ques <code>numpy</code> et <code>matplotlib.pyplot</code>: <pre><code>import math as m\nprint(m.pi)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n</code></pre></p>"},{"location":"TP1/#premiere-bibliotheque-math","title":"Premi\u00e8re biblioth\u00e8que: math","text":"<p>Il faut importer lal biblioth\u00e8que math avant d'utiliser les focntions ou variables de cette biblioth\u00e8que.</p> math.pi math.floor(x) math.sqrt(x) \u03c0 \u230ax\u230b <code>math.floor(-3.7)==-4</code> \u221ax <code>math.sqrt(9)==3</code> <p><code>math.pi</code> n'est pas une fonction mais une variable, il ne faut donc pas \u00e9crire <code>math.pi()</code> mais <code>math.pi</code>.</p>"},{"location":"TP1/#bibliotheque-fractions","title":"Biblioth\u00e8que fractions","text":"<p>Ne pas \u00e9crire <code>from Fraction import *</code>, mais <code>from fractions import *</code>.</p> <p>Pour mieux comprendre: Le nom de la librairie est <code>fractions</code> et une classe (un \"outil\") de cette biblioth\u00e8que est <code>Fraction</code>. Un import est de la forme <code>from fichier import outil</code> ou fichier est le nom de la biblioth\u00e8que et outil est le nom de la classe, fonction ou variable qu'on souhaite utiliser.</p> <pre><code>from fractions import *\nnumerateur=3\ndenominateur=12\na=Fraction(numerateur, denominateur)\nprint(a.numerator) # Renvoie le d\u00e9nominateur de la fraction simplifi\u00e9e\nprint(a.denominator) # Renvoie le num\u00e9rateur de la fraction simplifi\u00e9e\nprint(a) # Renvoie la fraction simplifi\u00e9e\nb=Fraction(2, 3)\nprint(a*b, a/b, a+b, a-b, a//b, a**b) # Renvoie: 1/6 3/8 11/12 -5/12 0 0.3968502629920499  M\u00eames op\u00e9rations que pour les nombres (int, float).\n</code></pre>"},{"location":"TP1/#symboles-de-tests","title":"Symboles de tests","text":"== &lt; &gt; != &lt;= &gt;= Egal Strict. inf. Strict. sup. N'est pas \u00e9gal Inf. ou \u00e9gal Sup. ou \u00e9gal Symbole Signification :-: :- == \u00c9gal &lt; Strictement inf\u00e9rieur &gt; Strictement sup\u00e9rieur != N'est pas \u00e9gal &lt;= Inf\u00e9rieur ou \u00e9gal &gt;= Sup\u00e9rieur ou \u00e9gal <p>Si le test est vrai (Ex: <code>6==2*3</code>), alors il renvoie <code>True</code>, sinon <code>False</code>.</p>"},{"location":"TP2/","title":"TP 2 - Boucles for et while, tests","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p>"},{"location":"TP2/#fonction-input-et-eval","title":"Fonction input et eval","text":"<p>La fonction <code>input()</code> permet de demander une valeur \u00e0 l'utilisateur. Cette valeur peux \u00eatre n'importe quelle cha\u00eene de caract\u00e8res. La valeur retourn\u00e9e par input sera toujours une cha\u00eene de caract\u00e8re <code>str</code>, m\u00eame si on entre une valeur comme <code>34</code>, <code>1.8</code> ou <code>True</code>.</p> <p><code>input</code> prend 1 argument qui est le texte affich\u00e9 dans la demande de la valeur (Exemple: <code>input(\"Donnez un entier entre 1 et 10: \")</code>).</p> <p>Pour obtenir un <code>int</code> lorsque l'utilisateur entre un entier, un <code>float</code> lorsque l'utilisateur entre un nombre d\u00e9cimal, ..., il faut utiliser la fonction eval, qui gr\u00e2ce au contexte (donc gr\u00e2ce \u00e0 la \"forme\" de la valeur : 2 =&gt; int, 1.2 =&gt; float, ...), eval va transformer le <code>str</code> en un autre type.</p> <pre><code>print(input(\"Donne un nombre\")) # L'utilisateur entre 2 =&gt; le programme affiche \"2\"\nprint(eval(input(\"Donne un nombre\"))) # L'utilisateur entre 3 =&gt; le programme affiche 3\n</code></pre>"},{"location":"TP2/#boucles-for","title":"Boucles <code>for</code>","text":"<p>La boucle <code>for</code> permet de r\u00e9p\u00e9ter une action un nombre connu de fois.</p> <p>Elle est de la forme:</p> <p><pre><code>a=2\nb=7\nc=2\nfor i in range(a, b, c):\n    print(i) # Il faut indenter les lignes \u00e0 l'int\u00e9rieur de la boucle\n</code></pre> La boucle ci-dessus prends les valeurs entre a et b-1, avec a et b entiers. Si on ajoute la valeur c, on va avancer de c en c entre a et b, donc a, a+c, a+2c, ... jusqu'\u00e0 ce que a+kc soit sup\u00e9rieur ou \u00e9gal \u00e0 b (dans quel cas la boucle s'arr\u00eate).</p> <p>Par exemple, on peut utiliser cette boucle pour calculer u\u2099 :</p> <pre><code>u=2 # Valeur de u\u2080\nn=10\nfor i in range(n): # Lorsqu'on met une seule valeur, la boucle va de 0 \u00e0 n-1, donc la boucle se lance n fois.\n    u=u*3+4\nprint(u) # Affiche u\u2081\u2080\n</code></pre> <p>On peut utiliser la valeur i, qui prend les valeurs parcourues par range(a,b,c). Par exemple pour calculer la somme des entiers entre 0 et n:</p> <pre><code>S=0\nn=10\nfor i in range(n+1):\n    S=S+i\nprint(S)\n</code></pre> <p>La boucle <code>for</code> permet \u00e9galement de calculer la somme ou le produit de termes (qui peuvent \u00eatre en fonction de i):</p> <pre><code>s=0 # Pour les sommes de termes, il faut initialiser la variable \u00e0 0\na=2\nb=10\nfor i in range(a, b):\n    s=s+i+2\nprint(s)\n</code></pre> <p><pre><code>p=1 # Pour les produits de termes, il faut initialiser la variable \u00e0 1\na=2\nb=10\nfor i in range(a, b):\n    p=p*(i+2)\nprint(p)\n</code></pre> Pour calculer la limite d'une somme ou d'un produit, il suffit de choisir un b tr\u00e8s grand.</p>"},{"location":"TP2/#boucles-while","title":"Boucles <code>while</code>","text":"<p>La boucle <code>while</code> est utilis\u00e9e lorsqu'on veut r\u00e9p\u00e9ter une action tant qu'une condition n'est pas atteinte.</p> <p>Par exemple, pour afficher les entiers entre 0 et n-1:</p> <pre><code>a=0\nb=5\nwhile a&lt;b: # Ici, la boucle est r\u00e9pet\u00e9e jusqu'\u00e0 ce que a&gt;=b\n    print(a)\n    a=a+1\n</code></pre> <p>Gr\u00e2ce \u00e0 la boucle while, on peut trouver le premier k tel que u\u2096 est par exemple sup\u00e9rieur \u00e0 une valeur.</p> <pre><code>u=0 # La valeur de u\u2080\nk=0\nwhile u&lt;20:\n    k=k+1\n    u=u**2+2\nprint(k)\n</code></pre>"},{"location":"TP2/#fonctions-de-la-bibliotheque-math","title":"Fonctions de la biblioth\u00e8que <code>math</code>","text":"<p>Il faut importer math avant de les utiliser.</p> math.exp(x) math.log(x) math.log2(x) math.log10(x) e\u02e3 <code>math.exp(0)==1</code> ln(x) <code>math.log(1)==0</code> Logarithme base 2 <code>math.log2(8)==3</code> Logarithme base 10 <code>math.log10(10)==2</code>"},{"location":"TP2/#tests","title":"Tests","text":"<pre><code>a=eval(input(\"Donnez un chiffre appartenant \u00e0 Z: \"))\nif a==0:\n    print(\"a est \u00e9gal \u00e0 0\")\nelif a&gt;0:\n    print(\"a est sup\u00e9rieur \u00e0 0\")\nelse:\n    print(\"a est inf\u00e9rieur \u00e0 0\")\n</code></pre>"},{"location":"TP2/#fonction-de-la-bibliotheque-random","title":"Fonction de la biblioth\u00e8que random","text":"<pre><code>import random\nprint(random.random()) # Renvoie un float entre O inclu et 1 exclu\nprint(random.random()*10) # Renvoie un float entre 0 inclu et 10 exclu\nprint(random.random()*10+4) # Renvoie un float entre 4 inclu et 14 exclu\nprint(int(random.random()*10+5)) # Renvoie un int entre 4 inclu et 14 inclu\n\nprint(random.randint(4,14)) # Renvoie un int entre 4 inclu et 14 inclu\n</code></pre> <p>Ces fonctions existent \u00e9galement dans la biblioth\u00e8que <code>numpy</code>, mais certaines diff\u00e9rences sont pr\u00e9sentes. Par exemple, <code>numpy.random.randint(a, b)</code> renvoie un int entre a inclus et b exclus, alors que <code>random.randint(a, b)</code> renvoie un int entre a inclus et b inclus.</p> <pre><code>import numpy as np\nimport random as rd\nprint(np.random.random()) # Renvoie un float entre 0 inclu et 1 exclu\n\nprint(rd.randint(4,14)) # Renvoie un int entre 4 inclu et 14 inclu\nprint(np.random.randint(4,15)) # Renvoie un int entre 4 inclu et 15 exclu\n</code></pre>"},{"location":"TP2/#algorithme-de-conversion-en-binaire-base-2","title":"Algorithme de conversion en binaire (base 2)","text":"<pre><code>n = eval(input(\"Donnez un nombre entier naturel: \"))\nnbin = \"\"\nif n == 0:\n    nbin = \"0\"\nelse:\n    while n &gt; 0:\n        nbin = str(n%2) + nbin # Il faut ajouter les valeurs \u00e0 gauche\n        n //= 2\nprint(nbin)\n</code></pre>"},{"location":"TP2/#algorithme-de-dichotomie-version-sans-fonctions","title":"Algorithme de dichotomie (version sans fonctions)","text":"<p>Qu'il faudra soit apprendre par coeur, soit savoir retrouver rapidement.</p> <pre><code>p=eval(input(\"Pr\u00e9cision: \"))\na=eval(input(\"Valeur de a: \"))\nb=eval(input(\"Valeur de b: \"))\nwhile abs(b-a)&gt;p:\n    m=(a+b)/2\n    if (a**3+3*a-5)*(m**3+3*m-5)&lt;0:\n        b=m\n    else:\n        a=m\nprint([a,m,b]) # x est compris entre a et b, et (a+b)/2 est le milieu de cet intervalle, donc la meilleure approximation\n</code></pre>"},{"location":"TP2/#algorithme-de-dichotomie-version-avec-fonctions","title":"Algorithme de dichotomie (version avec fonctions)","text":"<pre><code>def d(a,b,f,p): # a et b deux r\u00e9els entre lesquels il faut trouver alpha tel que f(alpha)=0, f la fonction et p la pr\u00e9cision (par exemple 0.001)\n    while abs(b-a)&gt;p:\n        if f(a)*f((a+b)/2)&lt;0:\n            b=(a+b)/2\n        else:\n            a=(a+b)/2\n    return [a,(a+b)/2,b] # x est compris entre a et b, et (a+b)/2 est le milieu de cet intervalle, donc la meilleure approximation\ndef f(x): return x**3+3*x-5 # Mettre ici la fonction qu'il faut \u00e9tudier, par exemple x**3+3*x-5\nprint(d(10,1,f,0.0001))\n</code></pre>"},{"location":"TP3/","title":"TP 3 - Listes","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p>"},{"location":"TP3/#introduction-aux-listes","title":"Introduction aux listes","text":"<p>Une liste est une structure de donn\u00e9es qui contient une collection d'objets Python. Ces objets peuvent \u00eatre des <code>int</code>, <code>float</code>, <code>str</code>, <code>bool</code>, d'autres listes, des fonctions, ... Une liste est une structure ordonn\u00e9e, ce qui signifie que l'ordre des \u00e9l\u00e9ments est pr\u00e9serv\u00e9.</p> <p>Une liste s'\u00e9crit avec des crochets, et une virgule entre chaque objet de la liste.</p> <pre><code>liste_a = [1, -3, \"Bonjour\", \"\", True, 1.06, [\"Deuxi\u00e8me\", \"liste\"]]\nliste_b = [] # Une liste peut \u00eatre vide\n</code></pre> <p>Les \u00e9l\u00e9ments d'une liste sont num\u00e9rot\u00e9s, le premier \u00e9l\u00e9ment est l'\u00e9l\u00e9ment d'indice 0, le deuxi\u00e8me d'indice 1, ... De plus, le dernier \u00e9l\u00e9ment est l'\u00e9l\u00e9ment d'indice -1, l'avant dernier d'indice -2, ... Ce qui permet de pouvoir acc\u00e9der au dernier \u00e9l\u00e9ment de la liste sans conna\u00eetre la longueur de celle-ci.</p> <pre><code>liste_a = [1, -3, \"Bonjour\", \"\", True, 1.06, [\"Deuxi\u00e8me\", \"liste\"]]\n\nprint(liste_a[0]) # Renvoie 1\nprint(liste_a[2]) # Renvoie \"Bonjour\"\nprint(liste_a[6]) # Renvoie [\"Deuxi\u00e8me\", \"liste\"]\nprint(liste_a[-1]) # Renvoie [\"Deuxi\u00e8me\", \"liste\"]\nprint(liste_a[-2]) # Renvoie 1.06\n</code></pre> <p>Pour concat\u00e9ner, donc \"coller\" ensemble deux listes, on utilise l'op\u00e9rateur <code>+</code>. Pour \"coller\" la m\u00eame liste plusieurs fois une derri\u00e8re l'autre, on utilise l'op\u00e9rateur <code>*</code>.</p> <pre><code>liste_a = [1, 2, 3, 4]\nliste_b = [\"5\", \"6\", \"7\"]\nprint(liste_a+liste_b) # Renvoie [1, 2, 3, 4, \"5\", \"6\", \"7\"]\nprint(liste_b+liste_a) # Renvoie [\"5\", \"6\", \"7\", 1, 2, 3, 4]\nprint(liste_a*3) # Renvoie [1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]\n</code></pre> <p>On peut parcourir une liste en utilisant une boucle <code>for</code>:</p> <pre><code>v=\"\"\nfor i in [\"a\", \"b\", \"c\", \"d\"]:\n    v = v+i\nprint(v) # Renvoie \"abcd\"\n</code></pre> <p>De m\u00eame qu'une liste, on peut parcourir une cha\u00eene de caract\u00e8res:</p> <pre><code>liste=[]\nfor i in \"Une phrase\":\n    liste = liste+[i]\nprint(liste) # Renvoie ['U', 'n', 'e', ' ', 'p', 'h', 'r', 'a', 's', 'e']\n</code></pre> <p>Pour ajouter un \u00e9l\u00e9ment \u00e0 une liste, on utilise la fonction <code>.append()</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\nliste.append(\"bonjour\")\nprint(liste) # Renvoie ['1', 'b', True, 'bonjour']\n</code></pre> <p>Pour changer la valeur d'un \u00e9l\u00e9ment on utilise l'op\u00e9rateur <code>=</code>:</p> <pre><code>liste=[\"1\", 4, True]\nliste[1]=23.3\nprint(liste) # Renvoie ['1', 23.3, True]\n</code></pre> <pre><code>p=[0,2,4,6,8,10]\nfor k in range(0,6):\n    p[k]=p[k]+1\nprint(p) # Renvoie [1, 3, 5, 7, 9, 11]\n</code></pre> <p>Pour connaitre le nombre d'\u00e9l\u00e9ments d'une liste, on utilise la fonction <code>len()</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\nprint(len(liste)) # Renvoie 3\n</code></pre> <p>Pour supprimer un \u00e9l\u00e9ment d'une liste dont on connait l'emplacement dans la liste, on utilise le mot cl\u00e9 <code>del</code>:</p> <pre><code>liste=[\"1\",\"b\", True]\ndel liste[1]\nprint(liste) # Renvoie ['1', True]\n</code></pre> <p>On peut cr\u00e9er des listes de listes (utile pour les matrices par exemple):</p> <pre><code>liste=[[1,2,3],[4,5,6],[7,8,9]]\nprint(liste[1][2]) # Renvoie 6\nprint(liste[2][-1]) # Renvoie 9\n\nl1=[1,2,3]\nl2=[4,5,6]\nliste=[l1,l2]\nprint(liste[1]) # Renvoie [4,5,6]\n</code></pre> <p>Pour extraire une partie de liste, on utilise la syntaxe <code>[debut:fin:pas]</code> (on appelle cette manipulation <code>slicing</code>): La valeur finale n'est pas atteinte. <pre><code>liste=[1,2,3,4,5,6,7,8,9]\nprint(liste[1:5]) # Renvoie [2, 3, 4, 5]\nprint(liste[1:5:2]) # Renvoie [2, 4]\nprint(liste[::2]) # Renvoie [1, 3, 5, 7, 9]\nprint(liste[::-1]) # Renvoie [9, 8, 7, 6, 5, 4, 3, 2, 1]\nprint(liste[5:2:-1]) # Renvoie [6, 5, 4]\n</code></pre></p>"},{"location":"TP3/#fonctions-utiles-pour-les-listes","title":"Fonctions utiles pour les listes","text":"<ul> <li><code>.count(\u00e9l\u00e9ment)</code>: Permet de compter le nombre d'occurences d'un \u00e9l\u00e9ment dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.count(\"a\")) # Renvoie 4\n</code></pre> <ul> <li><code>.index(\u00e9l\u00e9ment)</code>: Permet de connaitre l'indice de la premi\u00e8re occurence d'un \u00e9l\u00e9ment dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.index(\"b\")) # Renvoie 1\n</code></pre> <ul> <li><code>.pop(index)</code>: Supprime un \u00e9l\u00e9ment d'une liste \u00e0 un index (emplacement dans la liste) sp\u00e9cifique et renvoye cet \u00e9l\u00e9ment. Si aucun index n'est sp\u00e9cifi\u00e9, elle supprime et retourne le dernier \u00e9l\u00e9ment de la liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\", \"a\", \"a\"]\nprint(liste.pop(3)) # Renvoie \"b\"\nprint(liste) # Renvoie ['a', 'b', 'a', 'c', 'b', 'a', 'a']\nvar = liste.pop()\nprint(var) # Renvoie \"a\"\nprint(liste) # Renvoie ['a', 'b', 'a', 'c', 'b', 'a']\n</code></pre> <ul> <li><code>.insert(index, \u00e9l\u00e9ment)</code> : Permet d'ins\u00e9rer un \u00e9l\u00e9ment \u00e0 un index sp\u00e9cifique.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.insert(2, \"d\")\nprint(liste) # Renvoie ['a', 'b', 'd', 'a', 'b', 'c', 'b']\n</code></pre> <ul> <li><code>.reverse()</code> : Permet d'inverser l'ordre des \u00e9l\u00e9ments d'une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.reverse()\nprint(liste) # Renvoie ['b', 'c', 'b', 'a', 'b', 'a']\n</code></pre> <ul> <li><code>.remove(\u00e9l\u00e9ment)</code> : Permet de supprimer la premi\u00e8re occurence d'un \u00e9l\u00e9ment dans une liste.</li> </ul> <pre><code>liste=[\"a\", \"b\", \"a\", \"b\", \"c\", \"b\"]\nliste.remove(\"b\")\nprint(liste) # Renvoie ['a', 'a', 'b', 'c', 'b']\n</code></pre> <ul> <li><code>.sort()</code> : Permet de trier une liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nliste.sort()\nprint(liste) # Renvoie [-5, 1, 1, 2, 3, 3, 4, 5, 5, 6, 9]\nliste2=[\"a\", \"c\", \"b\", \"d\"]\nliste2.sort()\nprint(liste2) # Renvoie ['a', 'b', 'c', 'd']\n</code></pre> <ul> <li><code>max(liste)</code> : Permet de connaitre la valeur maximale d'une liste, <code>min(liste)</code> : Permet de connaitre la valeur minimale d'une liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nprint(max(liste)) # Renvoie 9\nprint(min(liste)) # Renvoie -5\n</code></pre> <ul> <li><code>sum(liste)</code> : Permet de calculer la somme de tout les \u00e9l\u00e9ments de la liste.</li> </ul> <pre><code>liste=[3, 1, 4, 1, -5, 9, 2, 6, 5, 3, 5]\nprint(sum(liste)) # Renvoie 34\n</code></pre>"},{"location":"TP3/#divers","title":"Divers","text":"<ul> <li>On peut g\u00e9n\u00e9rer des listes gr\u00e2ce \u00e0 des boucles <code>for</code>:</li> </ul> <pre><code>liste=[i for i in range(10)]\nprint(liste) # Renvoie [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nliste=[i for i in range(10) if i%2==0]\nprint(liste) # Renvoie [0, 2, 4, 6, 8]\nabscisse=[0, 1, 2, 3, 4, 5, 6, 7 ]\nordonn\u00e9e=[ 3*x+5 for x in abscisse] # Images des \u00e9l\u00e9ments de abscisse par la fonction x \u21a6 3*x+5\nprint(ordonn\u00e9e) # Renvoie [5, 8, 11, 14, 17, 20, 23, 26]\n</code></pre> <ul> <li>Copie des listes et effet de bord</li> </ul> <p>En Python, lorsqu'on affecte une liste \u00e0 une autre variable avec =, cela ne cr\u00e9e pas une nouvelle liste mais une r\u00e9f\u00e9rence vers la m\u00eame liste. Toute modification de l'une affectera donc l'autre.</p> <pre><code>liste_a = [1, 2, 3]\nliste_b = liste_a  # liste_b r\u00e9f\u00e9rence la m\u00eame liste que liste_a\nliste_b.append(4)\n\nprint(liste_a)  # Renvoie [1, 2, 3, 4]\nprint(liste_b)  # Renvoie [1, 2, 3, 4]\n</code></pre> <p>Pour \u00e9viter cet effet de bord, on peut utiliser la m\u00e9thode <code>.copy()</code>, <code>list()</code>, ou le slicing <code>[:]</code> afin de cr\u00e9er une vraie copie ind\u00e9pendante de la liste :</p> <pre><code>liste_a = [1, 2, 3]\n\n# Copie ind\u00e9pendante de liste_a\nliste_b = liste_a.copy()  \nliste_c = list(liste_a)\nliste_d = liste_a[:]  # Slicing\n\nliste_b.append(4)\nprint(liste_a)  # Renvoie [1, 2, 3] (liste_a n'a pas \u00e9t\u00e9 modifi\u00e9e)\nprint(liste_b)  # Renvoie [1, 2, 3, 4]\nprint(liste_c)  # Renvoie [1, 2, 3]\nprint(liste_d)  # Renvoie [1, 2, 3]\n</code></pre>"},{"location":"TP4/","title":"TP 4 - Fonctions","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p> <p>L'instruction <code>def</code> permet de d\u00e9finir une fonction. Cela permet d'\u00e9viter de r\u00e9\u00e9crire le m\u00eame code \u00e0 plusieurs endroits dans un programme et de r\u00e9utiliser ais\u00e9ment des morceaux de code. On peut ainsi appeler la fonction \u00e0 tout moment dans le programme.</p>"},{"location":"TP4/#definir-une-fonction","title":"D\u00e9finir une fonction","text":"<p>Pour cr\u00e9er une fonction, on utilise le mot-cl\u00e9 <code>def</code> suivi du nom de la fonction, de ses param\u00e8tres entre parenth\u00e8ses, et d\u2019un deux-points. Le corps de la fonction est indent\u00e9. Par exemple :</p> <pre><code>def fonction(x):\ny = x**2\nreturn y\nreturn \"patate\"  # Cette ligne ne sera jamais ex\u00e9cut\u00e9e\n</code></pre> <p>Attention : d\u00e8s qu'un <code>return</code> est rencontr\u00e9, la fonction se termine. Ici, le second <code>return</code> ne sera jamais atteint.</p>"},{"location":"TP4/#differentes-formes-usuelles-de-fonctions","title":"Diff\u00e9rentes formes usuelles de fonctions","text":"<ul> <li>Proc\u00e9dures</li> </ul> <p>Une fonction qui n'utilise pas de <code>return</code> est appel\u00e9e une proc\u00e9dure. Elle sert principalement \u00e0 ex\u00e9cuter des instructions (par exemple, afficher des r\u00e9sultats) sans renvoyer de valeur.</p> <pre><code>def affiche_message():\nprint(\"Bonjour\")\n</code></pre> <ul> <li>Fonctions avec conditions</li> </ul> <p>On peut int\u00e9grer des conditions dans une fonction pour modifier son comportement en fonction des valeurs d'entr\u00e9e :</p> <pre><code>def signe(x):\nif x &gt; 0:\n    return \"positif\"\nelif x &lt; 0:\n    return \"n\u00e9gatif\"\nelse:\n    return \"nul\"\n</code></pre> <ul> <li>Fonctions avec plusieurs arguments</li> </ul> <p>Les fonctions peuvent prendre plusieurs param\u00e8tres, ce qui permet de travailler sur plusieurs valeurs \u00e0 la fois :</p> <pre><code>def somme(a, b, c):\nreturn a + b + c\n</code></pre> <ul> <li>Fonctions appelant d\u2019autres fonctions</li> </ul> <p>Une fonction peut faire appel \u00e0 une autre pour r\u00e9aliser une t\u00e2che plus complexe :</p> <pre><code>def carre(x):\nreturn x**2\n\ndef somme_des_carres(a, b):\nreturn carre(a) + carre(b)\n</code></pre> <ul> <li>Fonctions r\u00e9cursives</li> </ul> <p>Une fonction r\u00e9cursive s'appelle elle-m\u00eame pour r\u00e9soudre un probl\u00e8me en le d\u00e9composant en sous-probl\u00e8mes plus simples. Il est essentiel de pr\u00e9voir une condition d'arr\u00eat pour \u00e9viter une r\u00e9cursion infinie.</p> <p>Quelques exemples : <pre><code>def factorielle(n):\nif n == 0:\n    return 1\nelse:\n    return n * factorielle(n - 1)\n</code></pre></p> <pre><code>def fibonacci(n):\nif n == 0:\n    return 0\nelif n == 1:\n    return 1\nelse:\n    return fibonacci(n - 1) + fibonacci(n - 2)\n</code></pre> <pre><code>def puissance(x, n):\n\"\"\"\nCalcul de la puissance n-i\u00e8me d\u2019un r\u00e9el x.\n\"\"\"\nif n == 0:\n    if x == 0:\n        print(\"impossible\")\n    else:\n        return 1\nelif n % 2 == 0:\n    y = puissance(x, n // 2) ** 2\nelse:\n    y = x * puissance(x, n - 1)\nreturn y\n\nx = eval(input(\"Entrer le r\u00e9el x : \"))\nn = eval(input(\"Entrer la puissance enti\u00e8re positive n : \"))\nprint(puissance(x, n))\n</code></pre> <pre><code>def u(n):\n\"\"\"\nCalcule le n-i\u00e8me terme de la suite d\u00e9finie par :\nU_0 = 1\nU_n = (U_{n-1} + 1) / (U_{n-1} + 2)\n\"\"\"\nif n == 0:\n    return 1\n# Appel r\u00e9cursif :\nu_prec = U(n - 1)\nreturn (u_prec + 1) / (u_prec + 2)\n</code></pre> <pre><code>def count_digits(n):\n\"\"\"\nRenvoie le nombre de chiffres qui composent l'entier n.\nOn utilise la division euclidienne par 10 pour retirer le dernier chiffre.\n\"\"\"\nn = abs(n) # On travaille avec la valeur absolue pour g\u00e9rer les nombres n\u00e9gatifs\n\nif n &lt; 10:\n    return 1 # Cas de base : s'il n'y a qu'un seul chiffre, on renvoie 1.\n\nelse:\n    return 1 + count_digits(n // 10)# Appel r\u00e9cursif : on enl\u00e8ve le dernier chiffre et on ajoute 1 au r\u00e9sultat.\n\n# Exemples de test :\nprint(count_digits(5))      # Affiche 1\nprint(count_digits(1234))   # Affiche 4\nprint(count_digits(0))      # Affiche 1\nprint(count_digits(-98765)) # Affiche 5\n</code></pre>"},{"location":"TP5/","title":"TP 5 - Matrices avec Numpy","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p>"},{"location":"TP5/#creation-de-matrices","title":"Cr\u00e9ation de matrices","text":"<p>Pour cr\u00e9er une matrice, il faut utiliser la fonction <code>array</code> de la biblioth\u00e8que <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # Renvoie [[1 2 3] [4 5 6] [7 8 9]]\nprint(matrice)\n</code></pre> <pre><code>from numpy import *\nmatrice=array([[1, 2, 3], [4, 5, 6]])\nprint(matrice) # Renvoie [[1 2 3] [4 5 6]]\n</code></pre> <p>Sur python, il est possible de revenir \u00e0 la ligne entre les diff\u00e9rents objets d'une liste, afin de rendre la liste ou matrice plus lisible.</p> <pre><code>import numpy as np\nmatrice=np.array([\n    [1, 2, 3],\n    [4, 5, 6],\n    [7, 8, 9]\n    ])\nprint(matrice) # Renvoie [[1 2 3] [4 5 6] [7 8 9]]\n</code></pre> <p>Certaines matrices utiles sont g\u00e9n\u00e9r\u00e9es gr\u00e2ce \u00e0 des fonctions:</p> <pre><code>import numpy as np\nmatrice0=np.zeros((3, 3))\nprint(matrice0) # Renvoie [[0 0 0] [0 0 0] [0 0 0]]\nmatrice1=np.ones((2, 3))\nprint(matrice1) # Renvoie [[1 1 1] [1 1 1]]\nidentite=np.eye(4)\nprint(identite) # Renvoie [[1. 0. 0. 0.] [0. 1. 0. 0.] [0. 0. 1. 0.] [0. 0. 0. 1.]]\n</code></pre>"},{"location":"TP5/#fonctions-et-operations-sur-les-matrices","title":"Fonctions et op\u00e9rations sur les matrices","text":"<p>Pour acc\u00e9der \u00e0 un \u00e9l\u00e9ment d'une matrice, on utilise les crochets <code>[ligne, colonne]</code>, presque comme pour les listes. Il est \u00e9galement possible d'utilises les <code>:</code></p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3],\n                [4, 5, 6],\n                [7, 8, 9]])\nprint(matrice[1, 2]) # Renvoie 6\nprint(matrice[1:3]) # Renvoie [[4 5 6] [7 8 9]]\nprint(matrice[1:3, 1:3]) # Renvoie [[5 6] [8 9]]\n</code></pre> <p>Pour connaitre le nombre d'\u00e9l\u00e9ments d'une matrice, on utilise la fonction <code>size</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(np.size(matrice)) # Renvoie 6\n</code></pre> <p>Pour connaitre le nombre de lignes et de colonnes d'une matrice, on utilise la fonction <code>shape</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(np.shape(matrice)) # Renvoie (2, 3)\n</code></pre> <p>Pour multiplier une matrice par une deuxi\u00e8me matrice, on utilise la fonction <code>dot</code> de <code>numpy</code>, ou l'op\u00e9rateur <code>@</code> \u00e0 partir de Python 3.5.</p> <pre><code>import numpy as np\nmatrice1=np.array([[1, 2, 3], [4, 5, 6]])\nmatrice2=np.array([[1, 2], [3, 4], [5, 6]])\nprint(np.dot(matrice1, matrice2)) # Renvoie [[22 28] [49 64]]\nprint(matrice1 @ matrice2) # Renvoie [[22 28] [49 64]]\n</code></pre> <p>Pour faire le produit terme \u00e0 terme de deux matrices, on utilise l'op\u00e9rateur <code>*</code>.</p> <pre><code>import numpy as np\nmatrice1=np.array([[1, 2, 3], [4, 5, 6]])\nmatrice2=np.array([[7, 8, 9], [10, 11, 12]])\nprint(matrice1*matrice2) # Renvoie [[7 16 27] [40 55 72]]\n</code></pre> <p>Pour obtenir la transpos\u00e9e d'ue matrice, on utilise la fonction <code>T</code> de <code>numpy</code>.</p> <pre><code>import numpy as np\nmatrice=np.array([[1, 2, 3], [4, 5, 6]])\nprint(matrice.T) # Renvoie [[1 4] [2 5] [3 6]]\n</code></pre> <p>Pour obtenir le d\u00e9terminant d'une matrice, on utilise la fonction <code>det</code> de <code>numpy.linalg</code>.</p> <pre><code>import numpy as np\nimport numpy.linalg as al\nmatrice22=np.array([[1, 2], [3, 4]])\nprint(al.det(matrice22)) # Renvoie -2.0000000000000004\n                            # (Python \u00e0 des probl\u00e8mes au niveau de l'arrondi lors des op\u00e9rations)\n</code></pre> <pre><code>import numpy as np\nfrom numpy.linalg import *\nmatrice33=np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(det(matrice33)) # Renvoie 0.0\n</code></pre> <p>Pour obtenir l'inverse d'une matrice, on utilise la focntion <code>inv</code> de <code>numpy.linalg</code>.</p> <pre><code>import numpy as np\nmatrice22=np.array([[1, 2], [3, 4]])\nprint(np.linalg.inv(matrice22)) # Renvoie [[-2. 1.], [ 1.5 -0.5]]\n</code></pre>"},{"location":"TP6/","title":"TP 6 - Repr\u00e9sentations graphiques avec Matplotlib","text":"<p>Les parties en italique sont des approfondissements qui pourraient \u00eatre utiles.</p>"},{"location":"TP6/#presentation-de-matplotlib","title":"Pr\u00e9sentation de Matplotlib","text":"<p>Matplotlib permet de cr\u00e9er des repr\u00e9sentations graphiques de donn\u00e9es. Il est possible de cr\u00e9er des graphiques en 2D et 3D, des histogrammes, des courbes, etc.</p> <p>Pour importer Matplotlib, il faut utiliser la commande suivante: <pre><code>import matplotlib.pyplot as plt\n</code></pre></p>"},{"location":"TP6/#creation-de-graphiques-simples","title":"Cr\u00e9ation de graphiques simples","text":"<p>Pour cr\u00e9er un graphique simple, il faut utiliser la fonction <code>plot</code> de Matplotlib. Il est possible de personnaliser le graphique en ajoutant des titres, des l\u00e9gendes, des axes, etc.</p> <pre><code>import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\nplt.plot(x, y) # Permet de dessiner la courbe, en reliant les diff\u00e9rents points\nplt.title(\"Graphique simple\") # Titre du graphique\nplt.xlabel(\"Axe des X\") # Titre de l'axe des X\nplt.ylabel(\"Axe des Y\") # Titre de l'axe des Y\nplt.show() # Affiche le graphique\n</code></pre> <p></p> <p>On peut aussi utiliser la fonction <code>scatter</code> pour cr\u00e9er un nuage de points. <pre><code>import matplotlib.pyplot as plt\nabscisses = [1, 2, 3, 4, 5]\nordonnees = [2, 3, 5, 7, 11]\nplt.scatter(abscisses, ordonnees) # Permet de dessiner un nuage de points\nplt.title(\"Nuage de points\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p>"},{"location":"TP6/#personnalisation-de-graphiques","title":"Personnalisation de graphiques","text":"<p>Il est possible de personnaliser les graphiques en ajoutant des titres, des l\u00e9gendes, des axes, etc. Il est aussi possible de changer la couleur et le style des lignes.</p> <pre><code>import matplotlib.pyplot as plt\n\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\n\nplt.plot(x, y, color='red', linestyle='--', linewidth=2) # Cr\u00e9e une ligne rouge en pointill\u00e9s de 2 pixels d'\u00e9paisseur\nplt.scatter(x, y, color='blue', marker='o', label=\"Point\") # Ajouter des points ronds sur la ligne\nplt.title(\"Graphique personnalis\u00e9\") # Titre du graphique\nplt.xlabel(\"Axe des X\") # Titre de l'axe des X\nplt.ylabel(\"Axe des Y\") # Titre de l'axe des Y\nplt.grid() # Affiche une grille\nplt.legend([\"Ligne rouge\",\n            \"Points de la ligne\"], loc=\"upper left\")\n# Affiche une l\u00e9gende, chaque \u00e9l\u00e9ment de la liste correspond \u00e0 un \u00e9l\u00e9ment du graphique,\n# dans l'ordre du code (plt.plot est en premier dans le code, donc \"Ligne rouge\" est en premier dans la liste)\n\nplt.show() # Affiche le graphique\n</code></pre> <p></p> <p>Il est \u00e9galement possible de cr\u00e9er une l\u00e9gende d'une autre fa\u00e7on: <pre><code>import matplotlib.pyplot as plt\nx = [1, 2, 3, 4, 5]\ny = [2, 3, 5, 7, 11]\nplt.plot(x, y, color='red', linestyle='--', linewidth=2, label=\"Ligne rouge\")\nplt.scatter(x, y, color='blue', marker='o', label=\"Points de la ligne\")\nplt.legend() # On ne met rien dans plt.legend car on a d\u00e9j\u00e0 mis les labels dans plt.plot et plt.scatter\nplt.show()\n</code></pre></p> <p></p>"},{"location":"TP6/#generer-des-graphiques-via-des-fonctions","title":"G\u00e9n\u00e9rer  des graphiques via des fonctions","text":"<p>Il faut en premier conna\u00eetre deux fonctions de <code>numpy</code>: - <code>linspace</code>: permet de cr\u00e9er une matrice de valeurs entre deux bornes, avec un nombre de valeurs donn\u00e9. Par exemple, <code>numpy.linspace(0, 10, 5)</code> cr\u00e9e une matrice de  5 valeurs entre 0 et 10: <code>[0., 2.5, 5., 7.5, 10.]</code> - <code>arange</code>: permet de cr\u00e9er un tableau de valeurs entre deux bornes, avec un pas donn\u00e9. Par exemple, <code>numpy.arange(0, 10, 2)</code> cr\u00e9e un tableau de valeurs entre 0 et 10, avec un pas de 2: <code>[0, 2, 4, 6, 8]</code></p> <p>Il faudra choisir entre ces deux fonctions en fonction de ce que l'on veut faire.</p> <p>Ces deux fonction g\u00e9nerent une matrice ligne. Il est donc possible d'utliser les fonctions math\u00e9matiques de <code>numpy</code> sur ces matrices. Par exemple, <code>numpy.exp</code> permet de calculer le sinus de chaque valeur de la matrice. <pre><code>import numpy as np\nx = np.linspace(0, 10, 5) # Cr\u00e9e une matrice de 5 valeurs entre 0 et 10\ny = np.exp(x) # Cr\u00e9e une matrice des valeurs de exp(valeur) pour chaque valeur de la matrice x\nprint(y) # Affiche la matrice [1.00000000e+00 1.21824940e+01 1.48413159e+02 1.80804241e+03 2.20264658e+04]\n</code></pre></p> <p>Exemple en utilisant <code>linspace</code> pour la fonction <code>sinus</code>: <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nx = np.linspace(-2 * np.pi, 2 * np.pi, 100) # Cr\u00e9e un tableau de 100 valeurs entre -2pi et 2pi\ny = np.sin(x) # Cr\u00e9e un tableau de 100 valeurs entre -1 et 1\nplt.plot(x, y)\nplt.title(\"Sinus\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p> <p>Exemple en utilisant <code>arange</code> pour la fonction <code>log</code>: <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nx = np.arange(0.01, 10, 0.1) # Cr\u00e9e un tableau de valeurs entre 0.01 et 10, avec un pas de 0.1\ny = np.log(x) # Cr\u00e9e un tableau de valeurs entre 0 et 2.3\nplt.plot(x, y)\nplt.title(\"Logarithme\") # Titre du graphique\nplt.show() # Affiche le graphique\n</code></pre></p> <p></p>"},{"location":"TP6/#exemples","title":"Exemples","text":"<p>Voir Re\u0301visions sur les fonctions.ipynb.</p> <p>Fiche de l'Acad\u00e9mie de Versailles (donn\u00e9e par la prof): Fiche PDF</p> <p>Lien vers le fichier sur le site de l'Acad\u00e9mie de Versailles: https://phychim.ac-versailles.fr/IMG/pdf/tuto_python_matplotlib.pdf</p>"},{"location":"Toutes_les_fonctions_de_1ere_annee/","title":"Toutes les fonctions de 1\u00e8re ann\u00e9e","text":"<pre><code>import numpy as np\nimport math\nimport fractions\nimport random as rd\nimport matplotlib.pyplot as plt\n\n\nabs\nmin\nmax\nsum\nround\nint\nfloat\nstr\nbool\nlist\ninput\neval\nprint\nlen\nlist.append\nlist.copy\nlist.index\nlist.count\nlist.pop\nlist.remove\nlist.reverse\nlist.sort\nlist.insert\n\nnp.exp\nnp.log\nnp.log2\nnp.log10\nnp.pi\nnp.arange\nnp.linspace\nnp.size\nnp.shape\nnp.array\nnp.dot\nnp.eye\nnp.ones\nnp.zeros\nnp.array(...).T\nnp.linalg.det\nnp.linalg.inv\n\nmath.factorial\nmath.log\nmath.log2\nmath.log10\nmath.pi\nmath.exp\nmath.sqrt\nmath.sin\nmath.cos\nmath.tan\nmath.floor\nmath.ceil\n\nfractions.Fraction\nfractions.Fraction(...).numerator\nfractions.Fraction(...).denominator\n\nrd.random\nrd.randint\nrd.choice # Pas dans le programme mais tr\u00e8s utile, permet de choisir un \u00e9l\u00e9ment au hasard dans une liste\n\nplt.plot\nplt.scatter\nplt.bar\nplt.title\nplt.xlabel\nplt.ylabel\nplt.grid\nplt.legend\nplt.show\n</code></pre>"}]}