# DS Info – ECG 2 (2023–2024)

**A. BENADDI**  
**Lycée Kléber**

La correction se trouve à la fin du sujet.


---

Pour tout le DS, nous importerons les librairies :

```python
from math import *
import numpy as np
import numpy.random as rd
import matplotlib.pyplot as plt
```

---

## Exercice 1

Soit $(u_n)_n$ une suite convergente définie par :

$$
u_n = \sum_{k=1}^n \frac{1}{k} - \ln(n)
$$

1. Écrire une fonction Python `u` qui prend en argument un entier naturel $n$ non nul et qui renvoie la valeur de $u_n$.

2. On admet que

$$
\exists \gamma, \text{ tel que } \forall n \in \mathbb{N}^*, \gamma \le u_n \quad \text{et} \quad |u_n - \gamma| \le \frac{1}{n}.
$$

En utilisant la fonction `u`, écrire un programme en Python pour qu’il donne en sortie la valeur approchée de la limite de la suite $(u_n)$ à $\varepsilon$ près, où $\varepsilon$ est un réel assez petit, donné par l’utilisateur.

---

## Exercice 2

On pose :

$$
A = \begin{pmatrix}
1 & 1 & 1 \\
1 & 2 & 1 \\
1 & 1 & 3
\end{pmatrix}
$$

La matrice $A$ est inversible et

$$
g(x) = \frac{1}{x+1} + \frac{1}{x-1} + \frac{1}{x-2}, \quad \text{pour tout } x \in \mathbb{R} \setminus {-1,1,2}.
$$

On note $\alpha$ la plus grande valeur propre de $A$, telle que $4 < \alpha < 5$, solution de l’équation $g(x)=1$.

Recopier et compléter les lignes incomplètes de la fonction Python afin qu’elle renvoie une valeur approchée de $\alpha$ à $10^{-3}$ près à l’aide de la méthode de dichotomie.

```python
# valeur approchee
x, y = 4, 5
while ...:
    m = ...
    if ...:
        ...
    else:
        ...
return alpha
```

---

## Exercice 3

Dans cet exercice, toutes les variables aléatoires sont supposées définies sur un même espace probabilisé $(\Omega, \mathcal{A}, \mathbb{P})$.

On considère une urne contenant initialement une boule bleue et une boule rouge. On procède à des tirages successifs d’une boule au hasard selon le protocole suivant :

* si on obtient une boule bleue, on la remet dans l’urne et on ajoute une boule bleue supplémentaire ;
* si on obtient une boule rouge, on ne la remet pas dans l’urne et on arrête l’expérience.

On suppose que toutes les boules sont indiscernables au toucher et on admet que l’expérience s’arrête avec une probabilité égale à $1$.

On note $N$ la variable aléatoire égale au nombre de boules présentes dans l’urne à la fin de l’expérience.

### a)

On montre que :

$$
\forall n \in \mathbb{N} \setminus {0,1}, \quad \mathbb{P}(N=n) = \frac{1}{n(n-1)}
$$

et que la variable aléatoire $N$ n’admet pas d’espérance.

Écrire une fonction Python d’entête `def simuleN():` de façon à ce qu’elle renvoie une simulation de la variable aléatoire $N$.

---

On considère une suite $(X_n)_{n \in \mathbb{N}}$ de variables aléatoires indépendantes et de même loi. On suppose que, pour tout $n \in \mathbb{N}^*$, les variables aléatoires $X_1, \ldots, X_n$ et $N$ sont mutuellement indépendantes.

On définit la variable aléatoire

$$
T = \max(X_1, \ldots, X_N),
$$

ce qui signifie :

$$
\forall \omega \in \Omega, \quad T(\omega) = \max(X_1(\omega), \ldots, X_N(\omega)).
$$

Ainsi par exemple :

* si $N$ prend la valeur $3$, alors $T = \max(X_1, X_2, X_3)$ ;
* si $N$ prend la valeur $5$, alors $T = \max(X_1, X_2, X_3, X_4, X_5)$ ; etc.

On suppose que, pour tout $n \in \mathbb{N}$, la variable aléatoire $X_n$ suit la loi uniforme sur $[0,1]$.

On rappelle que l’instruction `rd.random()` renvoie une matrice $1 \times 1$ dont les coefficients sont des réalisations de variables aléatoires indépendantes suivant la loi uniforme sur $[0,1]$.

### b)

Écrire une fonction Python d’entête `def simuleT():` qui renvoie une simulation de la variable aléatoire $T$.

### c)

En notant $(T_1, \ldots, T_m)$ un échantillon de la v.a.r. $T$. Compléter la fonction d’entête `def EML(m)` qui renvoie un vecteur ligne à 3 coordonnées contenant chacune une simulation de la moyenne (espérance)

$$
E(T) = \frac{1}{m} \sum_{i=1}^m T_i.
$$

```python
def EML(m):
    E = np.zeros(...)
    for k in ...:
        echantillon = ...
        for i in ...:
            ...
    return E
```

---

## Exercice 4 — Une application probabiliste de la formule sommatoire de Poisson

Soit $p$ un réel vérifiant $0 < p < 1$.

Deux joueurs $A$ et $B$ lancent tour à tour une pièce de monnaie.

Le jet de la pièce donne « Pile » avec la probabilité $p$ et « Face » avec la probabilité $1-p$.

Le vainqueur de la partie est le joueur qui obtient « Pile » le premier, auquel cas la partie s’arrête.

Le premier lancer (de rang 1) est effectué par le joueur $A$.

Si la partie ne s’arrête pas, les trois lancers suivants (de rangs 2, 3 et 4) sont effectués par le joueur $B$, les suivants (de rangs 5, 6, 7, 8 et 9) par le joueur $A$, et ainsi de suite.

Après chaque changement de main, le joueur qui reprend la main ne peut ainsi effectuer (au maximum) que deux lancers de plus que ceux que vient d’effectuer l’autre joueur.

On suppose que les résultats des lancers successifs sont indépendants.

On écrit la fonction Python incomplète suivante :

```python
def jeu(p):
    i, v = 1, 1
    s, j = 1, 1
    while ...:
        i = ...
        j = ...
        if j > s:      # changement de main
            s = ...
            j = ...
    if v == 1:
        vainqueur = 'A vainqueur'
    else:
        vainqueur = 'B vainqueur'
    return vainqueur
```

1. Compléter la fonction Python ci-dessus qui simule une partie effectuée selon les règles précédentes et affiche le vainqueur.
2. Que représente la valeur de `i` après l’exécution de la fonction `jeu` ?
3. Préciser la signification de la variable `v`.
4. Compléter le code de la fonction `jeu` pour qu’elle affiche le nombre de lancers effectués par le joueur $A$.
5. Écrire un code Python permettant d’obtenir une valeur approchée de la probabilité que le vainqueur du jeu soit le joueur $A$. On admet qu’une valeur approchée de la probabilité d’un événement $A$ est la fréquence sur un grand nombre de simulations. On prendra dans le programme le nombre de simulations égal à $100000$.



# Correction DS Info — ECG2


---

Pour tout le DS, nous importons les librairies :

```python
from math import *
import numpy as np
import numpy.random as rd
import matplotlib.pyplot as plt
```

# Exercice 1 — 4 points

## Question 1 — 2 points

```python
def suiteu(n):
    u = 0
    for k in range(1, n+1):
        u = u + 1/k
    return u - log(n)
```

## Question 2 — 2 points

```python
epsilon = float(input('Donner un réel positif assez petit eps = '))
n = 1
while 1/n > 2*epsilon:
    n = n + 1

print('La valeur approchée de gamma est ', suiteu(n))
```

# Exercice 2 — 4 points

```python
def valeur_approchee():
    x, y = 4, 5
    while abs(x - y) > 0.0001:
        m = (x + y) / 2
        if (1/(m+1) + 1/(m-1) + 1/(m-2) - 1) * (1/(x+1) + 1/(x-1) + 1/(x-2) - 1) < 0:
            y = m
        else:
            x = m
    alpha = m
    return alpha
```

# Exercice 3 — 6 points

## Question a — 2 points

```python
def simuleN():
    b = 1   # b désigne le nombre de boules bleues dans l’urne
    N = 2
    while rd.random() < b/(b+1):
        b = b + 1
        N = N + 1
    return N
```

## Question b — 2 points

```python
def simuleT():
    N = simuleN()
    X = rd.random(N)
    T = max(X)
    return T
```

## Question c — 2 points

```python
def EML(m):
    E = np.zeros(3)
    for k in range(3):
        echantillon = np.zeros(m)
        for i in range(m):
            echantillon[i] = simuleT()
        E[k] = np.mean(echantillon)
    return E
```

# Exercice 4 — 6 points

## Question 1 — 1,5 points

```python
def jeu(p):
    i = 1
    v = 1
    s, j = 1, 1
    while rd.random() > p:
        i = i + 1
        j = j + 1
        if j > s:
            v = -v      # changement de main
            s = s + 2
            j = 1
    if v == 1:
        vainqueur = 'A vainqueur'
    else:
        vainqueur = 'B vainqueur'
    return vainqueur
```

## Question 2 — 0,5 point

`i` représente le nombre de lancers effectués depuis le début de la partie jusqu’à ce que le jeu s’arrête.

## Question 3 — 0,5 point

La variable `v` permet un changement de joueur au cours du jeu, donc permet de déterminer le vainqueur de la partie.

* si `v = 1`, le vainqueur est $A$ ;
* si `v = -1`, le vainqueur est $B$.

## Question 4 — 1,5 points

```python
def jeu_nb_A(p):
    i = 1
    v = 1
    s, j = 1, 1
    nb_lancers_A = 1   # initialisation
    while rd.random() > p:
        i = i + 1
        j = j + 1
        if j > s:
            v = -v      # changement de main
            s = s + 2
            j = 1
        if v == 1:
            nb_lancers_A = nb_lancers_A + 1
    if v == 1:
        vainqueur = 'A vainqueur'
    else:
        vainqueur = 'B vainqueur'
    return vainqueur, nb_lancers_A
```

## Question 5 — 2 points

```python
N = 100000
f = 0
p = float(input("Entrer la probabilité d’avoir Pile comprise entre 0 et 1, p = "))

for k in range(N):
    if jeu(p) == 'A vainqueur':
        f = f + 1

print('La valeur approchée de la probabilité que le vainqueur du jeu soit le joueur A est P(A) = ', f/N)
```
